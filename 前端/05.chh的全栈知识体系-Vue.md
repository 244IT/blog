# chh的全栈知识体系-Vue.js

## 01.Vue 简介

### 1.1Vue 简单认识

- [Vue 官网](https://cn.vuejs.org/v2/guide/)

- Vue（读音 /vjuː/，类似于 view）是一个渐进式的框架，什么是渐进式？ 
- - 渐进式意味着你可以将 Vue 作为应用的一部分嵌入其中，带来更丰富的交互体验
  - 或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统（比如：Core+Vue-router+Vuex）也可以满足你各种各样的需求

- Vue 有很多特点和Web开发中常见的高级功能

  * 解耦视图和数据

  - 可复用的组件
  - 前端路由技术
  - 状态管理
  - 虚拟DOM

### 1.2Vue 安装

安装Vue的方式有很多：

#### 方式一：直接CDN引入

你可以选择引入开发环境版本还是生产环境版本

```
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<!-- 生产环境版本，优化了尺寸和速度 -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
```

#### 方式二：下载和引入

- 开发环境：https://vuejs.org/js/vue.js
- 生产环境：https://vuejs.org/js/vue.min.js

#### 方式三：NPM 安装

```
npm install vue
```

### 1.3Vue 初体验

#### Hello World

```
<div class="div">{{message}}</div>
<script src="./js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.div',
    data: {
      message: 'Hello Vue!'
    }
  });
</script>
```

#### 展示列表

```
<div class="div">
  <ul>
  <li v-for="item in NBAStars">{{item}}</li>
</ul>
</div>
<script src="./js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.div',
    data: {
      NBAStars: ['林书豪', '杜兰特', '詹姆斯', '欧文', '库里']
    }
  });
</script>
```

#### 计数器

```
<div class="div">
  <h2>当前计数：{{counter}}</h2>
  <button @click='increment'>+</button>
  <button @click='decrement'>-</button>
</div>
<script src="./js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.div',
    data: {
      counter: 0
    },
    methods: {
      increment: function() {
        this.counter++
      },
      decrement: function() {
        this.counter--
      }
    }
  })
</script>
```

### 1.4Vue 中的 MVVM

#### 01.什么是MVVM

[MVVM框架理解及其原理实现](https://segmentfault.com/a/1190000015895017)



![图片.png](file://C:/Users/H/Pictures/%E5%89%8D%E7%AB%AF/vue/vue-base/MVVM.png?lastModify=1602343223)

- View 层：视图层，在前端开发中，通常就是 DOM 层，主要的作用是给用户展示各种信息
- Model 层：数据层，数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据
- VueModel 层：视图模型层，视图模型层是 View 和 Model 沟通的桥梁，一方面实现了 Data Binding（数据绑定），将 Model 的改变实时的反应到 View 中，另一方面它实现了 DOM Listener（DOM监听），当 DOM 发生一些事件（点击、滚动、touch 等）时，可以监听到，并在需要的情况下改变对应的 Data

#### 02.MVC 和 MVVM 的区别

[MVC 和 MVVM 的区别](https://www.jianshu.com/p/b0aab1ffad93)

- MVC

![图片.png](file://C:/Users/H/Pictures/%E5%89%8D%E7%AB%AF/vue/vue-base/MVVM1.png?lastModify=1602343223)

- MVVM

![图片.png](file://C:/Users/H/Pictures/%E5%89%8D%E7%AB%AF/vue/vue-base/MVVM2.png?lastModify=1602343223)

#### 03.Vue 的生命周期

![20200113231944171.png](file://C:/Users/H/Pictures/%E5%89%8D%E7%AB%AF/vue/vue-base/MVVM3.png?lastModify=1602343223)

![图片.png](file://C:/Users/H/Pictures/%E5%89%8D%E7%AB%AF/vue/vue-base/MVVM4.png?lastModify=1602343223)

## 02.Vue 基础语法

### 2.1.插值语法:Mustache

插值：将值插入到模板的内容中

```
<div class="div">
  <!-- 插到标签中 -->
  <h2>Hello {{name}}</h2>
  <!-- 使用了两个Mustach -->
  <h2>{{firstName}} {{lastName}}</h2>
  <!-- 也可以是表达式 -->
  <h2>{{counter*2}}</h2>
</div>
<script src="./js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.div',
    data: {
      name: 'VueJS',
      firstName: 'Yuanyang',
      lastName: 'Liao',
      counter: 100
    }
  });
</script>
```

### 2.2.v-once

在某些情况下，我们可能不希望界面中 Mustach 中的值随意的跟随改变，就可以使用一个 Vue 的指令：`v-once`

- 该指令后面不需要跟任何表达式
- 该指令表示元素和组件只渲染一次，不会随着数据的改变而改变

```
<div class="app">
  <h2>{{message}}</h2>
  <h2 v-once>{{message}}</h2> <!-- 只会渲染一次 -->
</div>
<script src="./js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      message: 'Liao'
    }
  })
</script>
```



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1580999963496-f8c6a1dd-d2f0-4ca1-b675-e4aff9d02d58.png)



### 2.3.v-html



某些情况下，我们从服务器请求到的数据本身就是一个 HTML 代码，如果我们直接通过 `{{}}` 来输出，会将 HTML 代码也一起输出，但如果希望按照 HTML 格式进行解析，并且显示对应的内容，可以使用 `v-html` 指令



`v-html` 指令后面往往会跟上一个 string 类型，会将 string 的 html 解析出来并且进行渲染



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1580999286442-ba502b8d-b5c3-4d82-a976-c91c733bb4d4.png)

### 2.4.v-text



- v-text 作用和 Mustache 比较相似，都是用于将数据显示在界面中
- v-text 通常情况下，接受一个 string 类型



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581000435736-b434e6c0-e6ae-4a6d-91ea-a45b360d1826.png)



### 2.5.v-pre



`v-pre` 用于跳过这个元素和它子元素的编译过程，显示原本的 Mustache 语法，将代码原封不动的解析出来



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581000782310-a79f7bd6-1229-4455-9fba-803051502e77.png)



### 2.6.v-cloak



将未解析出来的代码块进行隐藏，但基本不会用到



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581047269927-db77733e-9b5a-41d9-a8a2-e5d88fe1e62d.png)



## 2.2.绑定属性 v-bind

### v-bind 基本使用

Mustache 指令主要作用是将值插入到我们模板的内容当中，但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定，比如：

- 动态绑定 a 元素的 href 属性
- 动态绑定 img 元素的 src 属性



这时，可以使用 `v-bind` 指令来动态绑定属性，`v-bind` 用于绑定一个或多个属性值，或者向另一个组件传递 props值



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581049847345-76fb5f1e-b9e8-4c23-a67d-87826d128593.png)



### v-bind 语法糖



v-bind 有一个对应的语法糖（简写方式），在开发中，通常会使用语法糖的形式，因为这样更加简洁

简写方式如下：



```
<div class="app">
  <img :src="imgSrc" alt=""><br>
  <a :href="aHref">Vue.js官网</a>
</div>
```



即省略 v-bind，直接写 `:`



### v-bind 动态绑定 class



很多时候，我们希望动态的来切换 class，比如：

- 当数据为某个状态时，字体显示红色
- 当数据另一个状态时，字体显示黑色



绑定 class 有两种方式：

- 对象语法
- 数组语法



1. 对象语法



对象语法的含义是：class 后面跟的是一个对象

对象语法有下面这些用法：



```
用法一：直接通过{}绑定一个类
<h2 :class="{'active': isActive}">Hello World</h2>

用法二：也可以通过判断，传入多个值
<h2 :class="{'active': isActive, 'line': isLine}">Hello World</h2>

用法三：和普通的类同时存在，并不冲突
注：如果isActive和isLine都为true，那么会有title/active/line三个类
<h2 class="title" :class="{'active': isActive, 'line': isLine}">Hello World</h2>

用法四：如果过于复杂，可以放在一个methods或者computed中
注：classes是一个计算属性
<h2 class="title" :class="classes">Hello World</h2>
```



点击按钮，修改文字颜色：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581055016234-10c4920a-eeb6-41fb-901a-11cd70378d6a.png)



有时候，如果 `v-bind:class="{active:isActive,line:isLine}"` 中 class 的项太多，可以定义一个方法，将其放到 methods 中：



```
<div class="app">
  <!-- <h2 class="title" v-bind:class="{active:isActive,line:isLine}">{{message}}</h2> -->
  <h2 class="title" v-bind:class="getCLasses()">{{message}}</h2>
  <button v-on:click="btnClick">改变颜色</button>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      message: 'YuanyangLiao',
      isActive: true,
      isLine: true
    },
    methods: {
      btnClick: function() {
        this.isActive = !this.isActive
      },
      getCLasses: function() {
        return {
          active: this.isActive,
          line: this.isLine
        }
      }
    }
  })
</script>
```



1. 数组语法



数组语法的含义是：class 后面跟的是一个数组

数组语法有下面这些用法：



```
用法一：直接通过{}绑定一个类
<h2 :class="['active']">Hello World</h2>

用法二：也可以传入多个值
<h2 :class=“[‘active’, 'line']">Hello World</h2>

用法三：和普通的类同时存在，并不冲突
注：会有title/active/line三个类
<h2 class="title" :class=“[‘active’, 'line']">Hello World</h2>

用法四：如果过于复杂，可以放在一个methods或者computed中
注：classes是一个计算属性
<h2 class="title" :class="classes">Hello World</h2>
```



```
<div class="app">
  <h2 class="title" v-bind:class="[active,line]">{{message}}</h2>
  <h2 class="title" v-bind:class="getCLasses()">{{message}}</h2>
  <button v-on:click="btnClick">改变颜色</button>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      message: 'YuanyangLiao',
      active: 'active',
      line: true
    },
    methods: {
      btnClick: function() {
        this.isActive = !this.isActive
      },
      getCLasses: function() {
        return [this.active, this.line]
      }
    }
  })
</script>
```



### 案例：点击当前项变色



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581070943837-9b22d8a8-112f-4bbd-a4c5-d2e6f5248c51.png)



### v-bind 动态绑定 style



我们可以利用 `v-bind:style` 来绑定一些 CSS 内联样式



在写CSS属性名的时候，比如 `font-size`，可以使用驼峰式 (camelCase) `fontSize`，或短横线分隔 (kebab-case，记得用单引号括起来) `'font-size'`



绑定class有两种方式：

- 对象语法
- 数组语法



1. 对象语法



style 后面跟的是一个对象类型

- 对象的 key 是 CSS 属性名称
- 对象的 value 是具体赋的值，值可以来自于 data 中的属性



```
<div class="app">
  <!-- 50px 必须加上单引号 -->
  <h2 :style="{fontSize:'50px'}">{{message}}</h2>
  <!-- finalSize、finalColor当成一个变量使用 -->
  <h2 :style="{fontSize:finalSize + 'px',color:finalColor}">{{message}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      message: 'YuanyangLiao',
      finalSize: 100,
      finalColor: 'skyblue',
    },
  })
</script>
```



1. 数组语法



style 后面跟的是一个数组类型



```
<div class="app">
  <h2 :style="[baseStyles,baseStyles2]">{{message}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      message: 'YuanyangLiao',
      baseStyles: {
        color: 'red'
      },
      baseStyles2: {
        fontSize: '50px'
      },
    },
  })
</script>
```

## 2.3计算属性 computed

在模板中可以直接通过插值语法显示一些 data 中的数据，但是在某些情况下，可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示，这时可以使用计算属性 computed

### 计算属性 computed 的基本使用

比如：现在有 firstName 和 lastName 两个变量，需要显示完整的名称，可能直接使用空格将其隔开：

```
<h2>{{firstName}} {{lastName}}</h2>
```

或者使用加号拼接：

```
<h2>{{firstName + '' +lastName}}</h2>
```

但是如果多个地方都需要显示完整的名称，我们就需要写多个 `{{firstName}} {{lastName}}` 或 `{{firstName + '' +lastName}}` ，使代码看上去很不优雅

这时，可能想到，将`{{firstName + '' +lastName}}` 封装为一个函数，通过函数的方式调用，但其实最佳方案是使用计算属性：

```
<div class="app">
  <!-- 方式1 -->
  <h2>{{firstName}} {{lastName}}</h2>
  <!-- 方式2 -->
  <h2>{{firstName + ' ' + lastName}}</h2>
  <!-- 方式3 -->
  <h2>{{getFullName()}}</h2>
  <!-- 方式4 -->
  <h2>{{fullName}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      firstName: 'Yuanyang',
      lastName: 'Liao',
    },
    computed: {
      fullName() {
        return this.firstName + ' ' + this.lastName
      }
    },
    methods: {
      getFullName: function() {
        return this.firstName + ' ' + this.lastName
      }
    }
  })
</script>
```



计算属性中也可以进行一些更加复杂的操作，比如下面计算图书价格的例子：



```
<div class="app">
  <h2>图书总价为：{{totalPrice}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      books: [{
        id: 1001,
        name: '计算机操作原理',
        price: 108
      }, {
        id: 1002,
        name: 'JavaScript高级程序设计',
        price: 99
      }, {
        id: 1003,
        name: '计算机网络',
        price: 28
      }, {
        id: 1004,
        name: '数据结构',
        price: 46
      }, {
        id: 1005,
        name: 'C语言',
        price: 48
      }, ]
    },
    computed: {
      totalPrice: function() {
        let result = 0
        for (let i in this.books) {
          result += this.books[i].price
        }
        return result
      }
    },
  })
</script>
```



### 计算属性的 setter 和 getter



每个计算属性都包含一个 getter 和一个 setter，getter 用来读取值，setter 用来设置值（但 setter 不常用）



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581244010629-d83eba3c-4778-4a28-875e-0b33c8bf6f8b.png)



### couputed 与 methods 的区别



我们可能会考虑这样的一个问题：

  

- methods 和 computed 看起来都可以实现我们的功能，那么为什么还要多一个计算属性这个东西呢？
- 原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次



**computed 区别于 methods 的核心**



在官方文档中，强调了computed 区别于 methods 最重要的两点



1. computed 是属性调用，而 methods 是函数调用
2. computed 带有缓存功能，而 methods 没有



- computed 定义的方法，我们是以属性访问的形式调用的，`{{computedTest}}`，但是 methods 定义的方法，我们必须要加上`()`来调用，如`{{methodTest()}}`
- 我们可以将同一函数定义为一个方法而不是一个计算属性，两种方式的最终结果确实是完全相同的然而，不同的是计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，这就意味着只要 text 还没有发生改变，多次访问 getText 计算属性会立即返回之前的计算结果，而不必再次执行函数，而方法只要页面中的属性发生改变就会重新执行
- 对于任何复杂逻辑，都应当使用计算属性
- computed 依赖于 data 中的数据，只有在它的相关依赖数据发生改变时才会重新求值



## 2.4事件监听 v-on



### v-on 基本使用



在前端开发中，我们需要经常和用户进行交互，这个时候，就必须监听用户发生的事件，比如点击、拖拽、键盘事件等，在 Vue 中监听事件使用 v-on 指令



```
<div class="app">
  <h2>{{counter}}</h2>
  <!-- 常规写法 -->
  <button v-on:click="increment">+</button>
  <!-- 语法糖形式 -->
  <button @click="decrement">-</button>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      counter: 0
    },
    methods: {
      increment() {
        this.counter++
      },
      decrement() {
        this.counter--
      }
    }
  })
</script>
```



当通过 methods 中定义方法，以 `@click` 调用时，需要注意参数问题：

- 如果该方法不需要额外参数，那么方法后的 () 可以不添加，但如果方法本身中有一个参数，那么会默认将原生事件 event 参数传递进去
- 如果需要同时传入某个参数，同时需要 event 时，可以通过 `$event` 传入事件



```
<div class="app">
  <!-- 1.事件调用的方法没有参数：可以省略() -->
  <!-- <button @click="btnClick()">按钮1</button>
<button @click="btnClick">按钮2</button> -->

  <!-- 2.事件调用的方法有参数 -->
  <button @click="btnClick()">按钮1</button>
  <!-- undefined -->
  <button @click="btnClick(123)">按钮2</button>
  <!-- 123 -->
  <button @click="btnClick">按钮3</button>
  <!-- MouseEvent对象：vue会默认将浏览器产生的event对象作为参数传到方法中 -->

  <!-- 3.在事件定义时，即需要event对象，又需要其他参数 -->
  <button @click="btnClick(123,$event)">按钮</button>

</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      counter: 0
    },
    methods: {
      btnClick(event, num) {
        console.log(event, num);
      }
    }
  })
</script>
```



### v-on 修饰符



在某些情况下，我们拿到 event 的目的可能是进行一些事件处理，vue 提供了修饰符来帮助我们方便的处理一些事件：

- `.stop` ：调用 `event.stopPropagation()`
- `.prevent` ：调用 `event.preventDefault()`
- `.{keyCode | keyAlias}` ：只当事件是从特定键触发时才触发回调
- `.native` ：监听组件根元素的原生事件
- `.once` ：只触发一次回调



```
<div class="app">
  <!-- 1 .stop:停止冒泡 -->
  <div @click="divClick">divdiv
    <button @click.stop="btnClick">按钮</button>
  </div>

  <!-- 2. .prevent:阻止默认行为 -->
  <form action="baidu" method="post">
    <input type="submit" value="提交" @click.prevent="submitClick">
  </form>

  <!-- 3. .enter:监听enter按键 -->
  <input type="text" @keyup.enter="enterClick">

  <!-- 4. .once:点击回调只会触发一次 -->
  <button @click.once="btnClick2">按钮2</button>

</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      counter: 0
    },
    methods: {
      btnClick() {
        console.log("btnClick...")
      },
      divClick() {
        console.log("divClick...")
      },
      submitClick() {
        console.log("submitClick...")
      },
      enterClick() {
        console.log("enterClick...")
      },
      btnClick2() {
        console.log("btnClick2...")
      }
    }
  })
</script>
```



## 2.5条件和循环

### 条件判断



v-if、v-else-if、v-else 这三个指令与 JavaScript 的条件语句 if、else、else if 类似

vue 的条件指令可以根据表达式的值在 DOM 中渲染或销毁元素或组件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581498501573-0ff92aec-6366-468e-8e37-655c6f4b4b83.png)



**v-if** 



v-if 后面的条件为 false 时，对应的元素以及其子元素不会渲染，也就是不会有对应的标签出现在 DOM 中



**v-show**



v-show 的用法和 v-if 非常相似，也用于决定一个元素是否渲染



**v-show 和 v-if 的区别**



- v-if 是真正的条件渲染，会确保在切换过程中，条件块内的事件和子组件被销毁和重建（组件被重建将会调用created）
- v-show 不论如何，都会被渲染在 DOM 中，当条件为真值时，将会修改条件的 css 样式
- v-if 有更高的切换开销，v-show 有更高的初始渲染开销
- v-if 是动态的向 DOM 树内添加或者删除 DOM 元素，v-show 是通过设置 DOM 元素的 display 样式属性控制显隐
- v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件，v-show 只是简单的基于 css 切换
- v-if 是惰性的，如果初始条件为假，则什么也不做，只有在条件第一次变为真时才开始局部编译，v-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留
- v-if 有更高的切换消耗，v-show 有更高的初始渲染消耗
- v-if 适合运营条件不大可能改变，v-show适合频繁切换



**v-if 和 v-show 都可以决定一个元素是否渲染，那么开发中我们如何选择呢？**



v-if 当条件为 false 时，压根不会有对应的元素在 DOM 中

v-show 当条件为 false 时，仅仅是将元素的 display 属性设置为 none 而已



结论：

- 当需要在显示与隐藏之间切换很频繁时，使用 v-show 
- 当只有一次切换时，通过使用 v-if



### 案例：切换用户账号



```
<div class="app">
  <span v-if="isUser">
    <label for="username">用户账号</label>
    <input type="text" id="username" placeholder="用户账号" key="username">
  </span>
  <span v-else>
    <label for="email">用户邮箱</label>
    <input type="text" id="email" placeholder="用户邮箱" key="email">
  </span>
  <button @click="isUser = !isUser">切换类型</button>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      isUser: true
    }
  })
</script>
```



### 循环 v-for



当我们有一组数据需要进行渲染时，我们就可以使用 v-for 来完成



v-for 的语法类似于 JavaScript 中的 for 循环：`item in items`



#### 遍历数组



```
<div class="app">
  <ul>
    <!-- 1.遍历数组的值 -->
    <li v-for="item in NBAStars">{{item}}</li>
    <!-- 2.遍历数组的索引和值 -->
    <li v-for="(item,index) in NBAStars">{{index+1}}.{{item}}</li>
  </ul>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      NBAStars: ['林书豪', '杜兰特', '詹姆斯', '欧文', '库里']
    }
  })
</script>
```



#### 遍历对象



```
<div class="app">
  <ul>
    <!-- 1.遍历对象的值 -->
    <li v-for="item in info">{{item}}</li><br>
    <!-- 2.遍历对象的键和值 -->
    <li v-for="(item,key) in info">{{key}} : {{item}}</li><br>
    <!-- 3.遍历对象的索引、键和值 -->
    <li v-for="(item,key,index) in info">{{index+1}}. {{key}} : {{item}}</li>
  </ul>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      info: {
        name: 'LiaoYuanyang',
        age: 18,
        gender: '男',
        height: 1.75
      }
    }
  })
</script>
```



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581509045500-64bf3703-0a1f-46df-bc4a-ee2ff5dda9b3.png)

#### 组件的 key 属性



官方推荐我们在使用 v-for 时，给对应的元素或组件添加上一个 `:key` 属性



为什么需要这个 key 属性呢，其实和 Vue 的虚拟 DOM 的 Diff 算法有关系，这里借用 React’s diff algorithm 中的一张图来简单说明一下：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581510137325-19587fb4-19a4-48fb-b7b8-8fcae2d01258.png)



当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581510235894-343d5441-f6cc-4e68-9e7a-8d6019039273.png)



我们希望可以在 B 和 C 之间加一个 F，Diff 算法默认执行起来是这样的：

即把 C 更新成 F，D 更新成 C，E 更新成 D，最后再插入 E：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581510288832-57f0b41f-b3c6-4f93-b9b1-b767ec2c0f6e.png)



是不是很没有效率？



所以我们需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点，所以，key 的作用主要是为了高效的更新虚拟 DOM



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581510389661-956e9c3e-7d70-4189-8a04-0d50cf98301f.png)

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581510373723-d98648d8-7b48-4b5c-838b-d100a3e21460.png)

```
<li v-for="item in info" :key="item">{{item}}</li>
```



### 案例：图书购物车



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581574445740-7012c8ef-6ec1-4cfd-80fc-89b357b87533.png)

index.html:



```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.min.css">
    <script src="jquery.min.js"></script>
    <script src="./bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
    <style>
        .app .table,
        .app .totalPrice {
            width: 800px;
            margin: 20px auto;
            padding: 20px;
        }
    </style>
</head>

<body>
    <div class="app">
        <div v-if="books.length">
            <table class="table table-hover">
                <thead>
                    <tr>
                        <th></th>
                        <th>书籍名称</th>
                        <th>出版日期</th>
                        <th>书本价格</th>
                        <th>购买数量</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="(item,index) in books">
                        <td>{{item.id}}</td>
                        <td>{{item.name}}</td>
                        <td>{{item.date}}</td>
                        <!-- <td>{{getFinallPrice(item.price)}}</td> -->
                        <td>{{item.price | showPrice}}</td>
                        <td>
                            <button type="button" class="btn btn-default" @click="decrement(index)" :disabled="item.count <=1">-</button>
                            <label>{{item.count}}</label>
                            <button type="button" class="btn btn-default" @click="increment(index)">+</button>
                        </td>
                        <td><button type="button" class="btn btn-warning" @click="removeClick(index)">移除</button></td>
                    </tr>
                </tbody>
            </table>
            <h2 class="totalPrice">总价格：{{totalPrice | showPrice}}</h2>
        </div>
        <h2 class="totalPrice" v-else>购物车为空！</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script src="main.js"></script>
</body>
</html>
```



main.js:



```
const app = new Vue({
    el: '.app',
    data: {
        books: [{
            id: 1001,
            name: '计算机操作原理',
            date: '2020-02-12',
            price: 108,
            count: 1
        }, {
            id: 1002,
            name: 'JavaScript高级程序设计',
            date: '2020-02-12',
            price: 99,
            count: 1
        }, {
            id: 1003,
            name: '计算机网络',
            date: '2020-02-12',
            price: 28,
            count: 1
        }, {
            id: 1004,
            name: '数据结构',
            date: '2020-02-12',
            price: 46,
            count: 1
        }, {
            id: 1005,
            name: 'C语言',
            date: '2020-02-12',
            price: 48,
            count: 1
        }]
    },
    methods: {
        // 普通方法处理价格
        getFinallPrice(price) {
            return '￥' + price.toFixed(2)
        },

        increment(index) {
            this.books[index].count++
        },
        decrement(index) {
            this.books[index].count--
        },
        removeClick(index) {
            this.books.splice(index, 1)
        },
    },
    computed: {
        totalPrice() {
            let totalPrice = 0
                // 方式一：for (let i in ...)
                /*  for (let i in this.books) {
                     totalPrice += this.books[i].price * this.books[i].count
                 } */
                // 方式二：for (let item of ...)
                /* for (let item of this.books) {
                    totalPrice += item.price * item.count
                } */
                // 方式三：高阶函数reduce：汇总数组内的元素
            this.books.reduce(function(preValue, book) {
                totalPrice += book.price * book.count
            }, 0)

            return totalPrice
        }
    },
    filters: {
        // 过滤器方法处理价格
        showPrice(price) {
            return '￥' + price.toFixed(2)
        }
    },
})
```

## 2.6表单绑定 v-model

### v-model 基本使用

表单控件在实际开发中是非常常见的，特别是对于用户信息的提交，需要大量的表单，vue 中使用 v-model 指令来实现表单元素和数据的双向绑定

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581583007867-a94a8db3-af27-4022-8a71-c062a35a1383.png)

案例解析：当我们在输入框输入内容时，因为 input 中的 v-model 绑定了 message，所以会实时将输入的内容传递给 message，message 发生改变，当 message 发生改变时，因为使用了 Mustache 语法，所以将 message 的值插入到 DOM 中，所以 DOM 会发生响应的改变，所以通过 v-model 实现了双向绑定

### v-model 原理

v-model 其实是一个语法糖，它的背后本质上是包含两个操作：

1. v-bind 绑定一个 value 属性
2. v-on 指令给当前元素绑定 input 事件

也就是说：

```
<input type="text" v-model="message">
```

等同于：

```
<input type="text" :value="message" @input="message = $event.target.value">
```

### v-model 结合 radio 使用

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581584184596-28721871-97c8-4b9f-a141-2e564e0a878c.png)



```
<div class="app">
  <label for="male">
    <input type="radio" v-model="gender" id="male" value="男">男
  </label>
  <label for="female">
    <input type="radio" v-model="gender" id="female" value="女">女
  </label>
  <h3>您选择的性别是：{{gender}}</h3>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      gender: '男'
    }
  });
</script>
```



### v-model 结合 checkbox 使用



- **checkbox 单选框**

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581585614457-dc7fe57a-907b-4d68-99c8-8ce09f520097.png)



```
<div class="app">
  <!-- checkbox单选框 -->
  <label for="licence">
    <input type="checkbox" v-model="isAgree" id="licence">同意协议
  </label>
  <h3>您的选择是：{{isAgree}}</h3>
  <button :disabled="!isAgree">下一步</button>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      isAgree: false
    }
  });
</script>
```



- **checkbox 多选框**

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581585338207-72b0ee9e-405c-4625-8179-1a3e5f35e404.png)



```
<div class="app">
  <h3>请选择您的爱好</h3>
  <label for="sing">
    <input type="checkbox" v-model="hobbies" id="sing" value="唱">唱
  </label>
  <label for="jump">
    <input type="checkbox" v-model="hobbies" id="jump" value="跳">跳
  </label>
  <label for="rap">
    <input type="checkbox" v-model="hobbies" id="rap" value="rap">rap
  </label>
  <label for="basketball">
    <input type="checkbox" v-model="hobbies" id="basketball" value="篮球">篮球
  </label>
  <h3>您的爱好是：{{hobbies}}</h3>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      hobbies: []
    }
  });
</script>
```



### v-model 结合 select 使用



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581586483452-3f260448-d6b5-4745-8592-01263d40f261.png)



```
<div class="app">
  <!-- 选择一个值 -->
  <h3>请选择您喜欢的水果：</h3>
  <select name="" v-model="fruit">
    <option value="苹果">苹果</option>
    <option value="香蕉">香蕉</option>
    <option value="橘子">橘子</option>
    <option value="西瓜">西瓜</option>
    <option value="榴莲">榴莲</option>
  </select>
  <h3>您选择的水果是：{{fruit}}</h3>

  <!-- 选择多个值 -->
  <select name="" v-model="fruits" multiple>
    <option value="苹果">苹果</option>
    <option value="香蕉">香蕉</option>
    <option value="橘子">橘子</option>
    <option value="西瓜">西瓜</option>
    <option value="榴莲">榴莲</option>
  </select>
  <h3>您选择的水果是：{{fruits}}</h3>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      fruit: '苹果',
      fruits: []
    }
  });
</script>
```



### v-model 修饰符



- lazy 修饰符
- - 默认情况下，v-model 是在 input 事件中同步输入框的数据，也就是说，一旦有数据发生改变，对应的 data 中的数据就会自动发生改变
  - lazy 修饰符可以让数据在失去焦点或者回车时才会更新



- number 修饰符
- - 默认情况下，在输入框中无论输入的是字母还是数字，都会被当做字符串类型进行处理，但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理
  - number 修饰符可以让在输入框中输入的内容自动转成数字类型



- trim 修饰符
- - 如果输入的内容首尾有很多空格，通常我们希望将其去除
  - trim 修饰符可以过滤内容左右两边的空格





```
<div class="app">
  <!-- 1.lazy修饰符：失去焦点或按下回车才更新 -->
  <input type="text" v-model.lazy="name">
  <h2>{{name}}</h2>
  <!-- 2.number修饰符：将输入框中的内容自动转为number -->
  <input type="number" v-model.number="age">
  <h2>{{age}}---{{typeof age}}</h2>
  <!-- 3.trim修饰符：过滤内容左右两边的空格 -->
  <input type="text" v-model.trim="name">
  <h2>你输入的名字是:{{name}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
  const app = new Vue({
    el: '.app',
    data: {
      name: 'YuanyangLiao',
      age: 18,
    }
  });
</script>
```



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581594893599-ccae53a3-df09-4268-b67e-12676e8e36d5.png)



# 03.组件化开发

## 3.1认识组件化

- 人面对复杂问题的处理方式：任何一个人处理信息的逻辑能力都是有限的，但人有一种天生的能力，就是将问题进行拆解，如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，会发现大的问题也会迎刃而解
- 组件化也是类似的思想：如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展，但如果将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了

**Vue 组件化思想**

组件化是 Vue.js 中的重要思想 ，它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用

任何的应用都会被抽象成一颗组件树：

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581596463796-57b0fc8e-ffa5-4a23-8642-a93e707ca664.png)



有了组件化的思想，我们在之后的开发中就要充分的利用它，尽可能的将页面拆分成一个个小的、可复用的组件，这样让我们的代码更加方便组织和管理，并且扩展性也更强

## 3.2.组件的使用步骤

组件的使用分成三个步骤：

1. 创建组件构造器
2. 注册组件
3. 使用组件

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581597914137-2c2cfb28-b998-491f-822c-72a53672f9cb.png)



注意：以上代码方式创建的组件是全局组件，即可以在多个 vue 的实例下使用，要改为局部组件，需要将注册方法写到具体的某个实例中

## 3.3全局组件和局部组件

当我们通过调用 `Vue.component()` 注册组件时，组件的注册是全局的 ，这意味着该组件可以在任意 Vue 实例下使用；如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581600197483-56477248-03ba-43d7-ae53-dd6cca81d55e.png)

## 3.4父组件和子组件

组件和组件之间存在层级关系，而其中一种非常重要的关系就是父子组件的关系

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581601754249-4ef9d5a7-bdfc-4e2e-abe5-eee75265940f.png)



## 3.5注册组件语法糖

在上面注册组件的方式，可能会有些繁琐，Vue为了简化这个过程，提供了注册的语法糖，主要是省去了调用`Vue.extend()` 的步骤，直接使用一个对象来代替

语法糖注册全局组件和局部组件：

```
<div class="app">
  <my-cpn1></my-cpn1>
  <my-cpn2></my-cpn2>
  </div>
  <script src="../js/vue.js"></script>
  <script>
    // 1. 注册全局组件的语法糖
    Vue.component('my-cpn1', {
    template: `
      <div>
      <h2>组件标题1</h2>
      <p>组件1中的一个段落内容</p>
      </div>
      `
  })
  const app = new Vue({
    el: '.app',
    // 2. 注册局部组件的语法糖
    components: {
      'my-cpn2': {
        template: `
          <div>
          <h2>组件标题2</h2>
          <p>组件2中的一个段落内容</p>
          </div>
          `
      }
    }
  })
</script>
```

## 注册组件模板分离

即使用 script 标签或 template 标签将模板内容从注册时的 template 中抽离出来

### 使用 \<script> 标签

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581603573378-04bbcac5-9583-419c-8164-f5c5455cccba.png)

### 使用 \<template> 标签

这种方式更为简单常用

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581603812779-af0467ed-4f0b-4270-b48b-5c6efbab76e5.png)

## 组件数据存放

组件是一个单独功能模块的封装，这个模块有属于自己的HTML模板，也应该有属性自己的数据 data，那么组件中的数据是保存在哪里呢？顶层的Vue实例中吗？

先来测试一下，组件中能不能直接访问 Vue 实例中的 data：

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581652953233-8cd7ad3a-92a5-4b33-91ee-9f4f1876d830.png)



通过以上代码发现，组件不能直接访问 Vue 实例中的 data，而且即使可以访问，如果将所有的数据都放在 Vue 实例中，Vue 实例就会变的非常臃肿

结论：Vue 组件应该有自己保存数据的地方

那么，组件自己的数据存放在哪里呢?

其实，组件对象也有一个 data 属性，只是这个 data 属性必须是一个函数，而且这个函数返回一个对象，对象内部保存着数据



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581653405094-d3b60214-4d54-4756-a258-bcdf7a663d07.png)



为什么 data 在组件中必须是一个函数呢?

- 首先，如果不是一个函数，Vue直接就会报错
- 其次，Vue 让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581654274206-2ee4ad1b-7784-4ba2-85b4-d615254de59a.png)



## 父子组件通信



- 父传子：props
- 子传父：自定义事件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581665402142-1bf8a31c-af94-4229-b35e-5e08380f0693.png)



### 父传子 props



在组件中，使用选项 props 来声明需要从父级接收到的数据



props 的值有两种方式：



1. 字符串数组，数组中的字符串就是传递时的名称



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581661254542-a74a3096-df42-4584-b0db-5acf06b83619.png)



1. 对象，对象可以设置传递时的类型，也可以设置默认值和类型等



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581659881608-172704a8-5261-4f5b-883a-9748041c03e8.png)



验证支持的数据类型：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581660077748-65e96b95-c5a2-4a1c-acb4-ca6dabdea74b.png)



### 子传父 自定义事件



自定义事件流程：

1. 在子组件中，通过 `$emit()` 来触发事件
2. 在父组件中，通过 `v-on` 来监听子组件事件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581665170967-f4907455-d2d5-4e00-a1e7-85ef0bded639.png)



### 双向绑定



```
<!-- 父组件模板 -->
<div class="app">
  <cpn :number1="num1" :number2="num2" @num1change="num1change" @num2change="num2change"></cpn>
</div>
<!-- 子组件模板 -->
<template id="cpn">
  <div>
    <h2>props:{{number1}}</h2>
    <h2>data:{{dnumber1}}</h2>
    <!-- <input type="text" v-model="dnumber1"> -->
    <input type="text" :value="dnumber1" @input="num1Input">
    <h2>props:{{number2}}</h2>
    <h2>data:{{dnumber2}}</h2>
    <!-- <input type="text" v-model="dnumber2"> -->
    <input type="text" :value="dnumber2" @input="num2Input">
  </div>
</template>
<script src="../js/vue.js"></script>
<script>
  // 父组件
  const app = new Vue({
    el: '.app',
    data: {
      num1: 1,
      num2: 0
    },
    methods: {
      num1change(value) {
        this.num1 = parseFloat(value)
      },
      num2change(value) {
        this.num2 = parseFloat(value)
      }
    },
    // 子组件
    components: {
      cpn: {
        template: '#cpn',
        // props中的数据只能父组件修改，通过使用标签动态绑定
        props: { // 父传子
          number1: Number,
          number2: Number
        },
        data() {
          return {
            dnumber1: this.number1,
            dnumber2: this.number2,
          }
        },
        methods: {
          num1Input(event) {
            // 将input中的vlaue赋值给dnumber1
            this.dnumber1 = event.target.value
            // 发射一个事件，让父组件可以修改值（子传父）
            this.$emit('num1change', this.dnumber1)
            // 修改dnumber2的值
            this.dnumber2 = this.dnumber1 * 100
            this.$emit('num2change', this.dnumber2)
          },
          num2Input(event) {
            this.dnumber2 = event.target.value
            this.$emit('num2change', this.dnumber2)
            this.dnumber1 = this.dnumber2 / 100
            this.$emit('num1change', this.dnumber1)
          }
        }
      }
    }
  })
</script>
```



图解关系：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581691742374-4d414cd7-c310-42ce-bb05-c83b6b6ec232.png)

## 父子组件访问



### 父组件访问子组件



父组件访问子组件有两种方式：

- $children（不常用）
- $refs（常用）



#### $children

`this.$children` 是一个数组类型，它包含所有子组件对象，可以通过遍历，取出所有子组件的信息



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581749320074-56287243-3602-4861-9447-f83d9fa302f6.png)



$children 的缺陷：

通过 $children 访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值，但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化



有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用 $refs



#### $refs



$refs 和 ref 指令通常是一起使用的：



1. 首先，我们通过 ref 给某一个子组件绑定一个特定的 ID

```
<cpn ref="child1"></cpn>
<cpn ref="child2"></cpn>
```



1. 其次，通过 `this.$refs.ID` 就可以访问到该组件了



```
console.log(this.$refs.child1.name);
console.log(this.$refs.child2.name);
```



### 子组件访问父组件（不常用）



子组件访问父组件通过：$parent

如果是向访问根组件，通过：$root

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581752277161-c34a1156-8e27-4707-8ef0-8a019cd362f1.png)



注意：

- 尽管在 Vue 开发中，我们允许通过 $parent 来访问父组件，但是在真实开发中尽量不要这样做，因为这样耦合度太高了
- 子组件应该尽量避免直接访问父组件的数据，如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题
- 另外，通过 $parent 直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于调试和维护
- 也不常用 $root 来访问根组件（即 vue 实例），因为根组件中一般只存放路由等重要数据，不存放其他信息



# 组件化高级



## 插槽 slot（Vue 2.6之前用法）



### 为什么使用 slot



slot 翻译为插槽，插槽的目的是让我们原来的设备具备更多的扩展性



组件的插槽，也是为了让我们封装的组件更加具有扩展性，让使用者可以决定组件内部的一些内容到底展示什么



### slot 基本使用



在子组件中，使用特殊的元素 `` 就可以为子组件开启一个插槽，该插槽插入什么内容取决于父组件如何使用



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581755392090-50402b58-faf0-4182-ab05-7b72aec65c03.png)



### 具名插槽 slot



当子组件的功能复杂时，子组件的插槽可能并非是一个，比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边



那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？这个时候，我们就需要给插槽起一个名字，这就是具名插槽

具名插槽的使用很简单，只要给 slot 元素一个 name 属性即可：``



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581756479617-fbf9889d-2ece-4857-8314-ad5295c776a1.png)



### 编译作用域



- 父组件模板的所有东西，都会在父级作用域内编译
- 子组件模板的所有东西，都会在子级作用域内编译



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581758268808-fc6bf027-23d7-4879-b4c0-b3c5646b644e.png)



### 作用域插槽



作用域插槽是 slot 一个比较难理解的点，一句话总结就是：



父组件替换插槽的标签，但是内容由子组件来提供



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581760739134-ccf0c61c-d1f4-402f-8627-679e45b1372e.png)



## 插槽slot（Vue 2.6之后用法）



> 在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 `v-slot` 指令)。它取代了 `slot` 和 `slot-scope` 这两个目前已被废弃但未被移除且仍在[文档中](https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法)的特性。新语法的由来可查阅这份 [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)。



slot 有三种类型



- 默认插槽 default
- 具名插槽 name
- 作用域插槽 v-slot



在子组件中：

- 插槽用 `标签来确定渲染的位置，里面放的是父组件没传内容时的后备内容，一个不带 name 的` 出口会带有隐含的名字 default
- 具名插槽用 name 属性来表示插槽的名字
- 作用域插槽在作用域上绑定属性来将子组件的信息传给父组件使用



有时我们需要多个插槽。例如对于一个带有如下模板的 `` 组件：



```
<div class="container">
  <header>
    <!-- 我们希望把页头放这里 -->
  </header>
  <main>
    <!-- 我们希望把主要内容放这里 -->
  </main>
  <footer>
    <!-- 我们希望把页脚放这里 -->
  </footer>
</div>
```



对于这样的情况，`` 元素有一个特殊的特性：`name`，这个特性可以用来定义额外的插槽：



```
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```



一个不带 name 的 <slot> 出口会带有隐含的名字“default”。



### v-slot



- 具名插槽通过指令参数 `v-slot:插槽名` 的形式传入，可以简化为 `#插槽名`
- 作用域插槽通过 `v-slot:xxx="slotProps"` 的 slotProps 来获取子组件传出的属性



```
//具名插槽的缩写
<template>
  <child>
   <!--默认插槽-->
   <template v-slot>  // v-slot:default
     <div>默认插槽</div>
   </template>
   <!--具名插槽-->
   <template #header>  // v-slot:header
     <div>具名插槽</div>
   </template>
   <!--作用域插槽-->
   <template #footer="slotProps">  //v-slot:footer
     <div>
      {{slotProps.testProps}}
     </div>
   </template>
  <child>
</template>
```



在向具名插槽提供内容的时候，我们可以在一个 `元素上使用`v-slot`指令，并以`v-slot` 的参数的形式提供其名称：



```
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```



现在 `元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有`v-slot`的` 中的内容都会被视为默认插槽的内容



然而，如果你希望更明确一些，仍然可以在一个 ` 中包裹默认插槽的内容：



```
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <template v-slot:default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
```



任何一种写法都会渲染出：



```
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
```



注意 **v-slot 只能添加在  上** (只有一种例外情况)，这一点和已经废弃的 `slot` 特性)不同。

### v-slot 作用域插槽



有时让插槽内容能够访问子组件中才有的数据是很有用的，例如，设想一个带有如下模板的 `` 组件：



```
<span>
  <slot>{{ user.lastName }}</slot>
</span>
```



我们可能想换掉备用内容，用名而非姓来显示，如下：



```
<current-user>
  {{ user.firstName }}
</current-user>
```



然而上述代码不会正常工作，因为只有 `` 组件可以访问到`user` 而我们提供的内容是在父级渲染的



为了让 `user` 在父级的插槽内容中可用，我们可以将 `user` 作为 `` 元素的一个特性绑定上去：



```
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>
```



绑定在 `` 元素上的特性被称为**插槽 prop**。现在在父级作用域中，我们可以使用带值的`v-slot` 来定义我们提供的插槽 prop 的名字：



```
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>
```



在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字



### 独占默认插槽的缩写语法



在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用，这样我们就可以把 v-slot 直接用在组件上：



```
<current-user v-slot:default="slotProps">
 {{ slotProps.user.firstName }}
</current-user>
```



这种写法还可以更简单，就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽：

```
<current-user v-slot="slotProps">
 {{ slotProps.user.firstName }}
</current-user>
```



注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：



```
<!-- 无效，会导致警告 -->
<current-user v-slot="slotProps">
 {{ slotProps.user.firstName }}
 <template v-slot:other="otherSlotProps">
   slotProps is NOT available here
 </template>
</current-user>
```



只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法：



```
<current-user>
 <template v-slot:default="slotProps">
   {{ slotProps.user.firstName }}
 </template>
 <template v-slot:other="otherSlotProps">
   ...
 </template>
</current-user>
```



### 解构插槽 Prop



作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里：



```
function (slotProps) {
 // 插槽内容
}
```



这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式



所以在支持的环境下 (单文件组件或现代浏览器)，你也可以使用 ES2015 解构来传入具体的插槽 prop，如下：



```
<current-user v-slot="{ user }">
 {{ user.firstName }}
</current-user>
```



这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 user 重命名为 person：



```
<current-user v-slot="{ user: person }">
 {{ person.firstName }}
</current-user>
```



你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：



```
<current-user v-slot="{ user = { firstName: 'Guest' } }">
 {{ user.firstName }}
</current-user>
```



注意：

- 默认插槽名为default，可以省略default直接写v-slot。缩写为#时不能不写参数，写成#default（这点所有指令都一样，v-bind、v-on）
- 多个插槽混用时，v-slot不能省略default
- 只要出现多个插槽，请始终为所有的插槽使用完整的基于<template> 的语法



### 动态插槽名（ 2.6.0 新增）



动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：



```
<base-layout>
 <template v-slot:[dynamicSlotName]>
   ...
 </template>
</base-layout>
```



# 04.Vue CLI



## 什么是 Vue CLI



如果你只是简单写几个 Vue 的 Demo 程序, 那么你不需要 Vue CLI

如果你在开发大型项目, 那么你需要, 并且必然需要使用 Vue CLI



使用 Vue.js 开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情，如果每个项目都要手动完成这些工作，效率比较低，所以通常我们会使用一些脚手架工具来帮助完成这些事情



**CLI 是什么意思**

CLI 是 Command-Line Interface , 翻译为命令行界面, 俗称脚手架

Vue CLI 是一个官方发布的 vue.js 项目脚手架

使用 vue-cli 可以快速搭建 Vue 开发环境以及对应的 webpack 配置



Vue CLI 使用前提：

- Node
- webpack



## Vue CLI 的使用



### 安装 Vue 脚手架



```
npm install -g @vue/cli
```



注意：上面安装的是 Vue CLI3 的版本，如果需要想按照 Vue CLI2 的方式初始化项目，还需要拉取 2.x 的模板



### 拉取 2.x 模板（旧版本）



```
npm i @vue/cli-init -g
```



### 初始化项目



#### Vue CLI2 初始化项目



```
vue init webpack vuecli2test
```

**vue cli 2 项目详解**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581926962910-fc27b205-e612-4e2d-84f3-462563a613aa.png)



**vue cli 2 目录详解**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581935903367-f26af9af-4554-4120-af0d-c3cefe6ebd5c.png)



#### Vue CLI3 初始化项目



```
vue create vuecli3test
```



vue-cli 3 与 2 版本有很大区别：

- vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3
- vue-cli 3 的设计原则是“0配置”，移除了根目录下的 build 和 config 等的配置文件目录
- vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化
- 移除了 static 文件夹，新增了 public 文件夹，并且 index.html 移动到 public 中



**vue cli 3 项目详解**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581944048596-1a072dbb-a4bf-4e73-9c17-48a92227ba68.png)



**vue cli 3 目录详解**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581944271556-a10b8758-3945-452f-8938-c79bd88e5f82.png)



### CLI 相关配置



#### Runtime-Compiler 和 Runtime-only 的区别

构建项目时：

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581939651445-21d93f1f-a52b-4cbf-8363-5a6a137d61c1.png)**

官方解释：

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581939705183-6a421066-3e2e-4a4b-961d-fe8c5d705525.png)**

简单总结：

- 如果在之后的开发中，你依然使用 template，就需要选择 Runtime-Compiler
- 如果你之后的开发中，使用的是 .vue 文件开发，那么可以选择 Runtime-only



**render 和 template**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581940035626-c828a7a9-0260-4ab3-aa45-6f304a91804f.png)



**Vue 程序运行过程**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581940280165-e1b47b6c-3cee-4415-8334-8b53e1cf70b2.png)

**render 函数的使用**

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581940598835-4ec575ef-bd1a-485b-92c8-ee351c3c10ff.png)**



#### npm run build



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581943320923-01bd82b2-8d77-4ba3-a434-3587f701478e.png)



#### npm run dev



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581943375889-79a90aee-6408-4dba-a525-7b37cf9a3be1.png)



#### 配置文件去向



在 Vue CLI 3 中，webpack 等相关配置文件被隐藏起来了，如果想查看或修改相关配置，可以通过以下3种方式：



1. 从 UI 界面上修改



- 启动配置服务器：`vue ui`
- 进入 Vue 项目管理器，导入我们的项目：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581946472716-b1c6bbb7-021e-4293-9faa-0fb5facc2cea.png)



- 然后可以在配置中查看或修改我们的 webpack 等配置：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581946617657-e9963bc3-d7de-495a-96cc-646cc58b44f0.png)



1. 在 node_modules 中寻找



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581946874252-5f870b5a-692d-44f0-a7ae-99a40cd8e511.png)



1. 在项目中新建一个 vue.config.js 文件，将需要修改的配置代码写入其中



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1581947083923-c75b2675-60c7-4757-8774-94cfd0c795f2.png)



最终编译时会自动将我们添加的代码与隐藏的代码进行合并



# 05.Vue-router



## 认识路由



### 什么是路由



> 路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动  — 维基百科



路由器提供了两种机制， 路由和转发

- 路由是决定数据包从来源到目的地的路径
- 转发将输入端的数据转移到合适的输出端



### 网站发展的几个阶段



#### 后端路由阶段



**什么是后端路由**



早期的网站开发，整个 HTML 页面都是是由服务器来渲染的，服务器直接生产渲染好对应的 HTML 页面, 返回给客户端进行展示



但是, 服务器如何处理一个网站的诸多页面呢?



首先，一个页面会有自己对应的网址, 也就是 URL，客户端发生请求时，URL 会发送到服务器，服务器通过正则对该URL 进行匹配且最后交给 Controller 进行处理，Controller 进行各种处理后，最终生成 HTML 或者数据，返回给前端，这就完成了一个IO操作，这种操作, 就是后端路由



**后端路由的优点**



当页面中需要请求不同的路径内容时，交给服务器来进行处理, 服务器渲染好整个页面，并且将页面返回给客户端，

这种情况下渲染好的页面，不需要单独加载任何的 js 和 css，可以直接交给浏览器展示，这样也有利于 SEO 的优化



**后端路由的缺点**

** **

- 整个页面的模块都要由后端人员来编写和维护，工作量太大
- 前端开发人员如果要开发页面，需要通过 PHP 和 Java 等语言来编写页面代码，增加了额外的学习成本
- HTML 代码和数据以及对应的逻辑混在一起,，不利于编写和维护



#### 前端路由阶段



前端路由的核心：改变URL，但是页面不进行整体的刷新



##### 前后端分离阶段



随着 Ajax 的出现，有了前后端分离的开发模式：后端只提供 API 来返回数据，前端通过 Ajax 获取数据，并且可以通过 JavaScript 将数据渲染到页面中



优点：

- 前后端责任变得很清晰，后端专注于数据上, 前端专注于交互和可视化上
- 当移动端(iOS/Android)出现后，后端不需要进行任何处理， 依然使用之前的一套API即可



##### 单页面富应用阶段



单页面富应用，即单页Web应用（single page web application，SPA），就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序



简单理解：就是在前后端分离的基础上加了一层前端路由



**SPA的特点**

** **

- 速度：更好的用户体验，让用户在 web app 感受 native app 的速度和流畅
- ·MVVM：经典 MVVM 开发模式，前后端各负其责
- ·ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交
- ·路由：在 URL 中采用 # 号来作为当前视图的地址，改变 # 号后的参数，页面并不会重载



**SPA 缺点**

** **

- 首屏渲染等待时长： 必须得加载完毕，才能渲染出首屏
- seo不友好：爬虫只能拿到一个 div，认为页面是空的，不利于 seo
- 初次加载耗时多：为实现单页Web应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面可以在需要的时候加载，所以必须对 JavaScript 及 CSS 代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的 CDN，因此带宽的消耗是必然的

** **

**SPA 优点**

** **

- 良好的交互体验 ：用户不需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示流畅
- 良好的前后端工作分离模式：单页 Web 应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作，更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分
- 减轻服务器压力：服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍
- 共用一套后端程序代码 ：不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端



### 改变 URL，页面不刷新



#### URL 的 hash



URL 的 hash 也就是锚点(#)，本质上是改变 window.location 的 href 属性，可以通过直接赋值 location.hash 来改变 href，但是页面不发生刷新



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582004833873-2c3ac18e-0ab0-4349-ab77-86719e1a14aa.png)



#### HTML5 的 history 模式

history 接口是 HTML5 新增的，它有五种模式改变 URL 而不刷新页面

- history.pushState()



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582005288315-2f1a201f-9e89-4b1d-9245-d5828f7b3428.png)



- history.replaceState()
- history.forward()
- history.back()
- history.go()

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582005440598-cefdad41-1fb4-4178-b405-7d5ea668a08a.png)



## Vue-router 基本使用



目前前端流行的三大框架，都有自己的路由实现：

- Angular：ngRouter
- React：ReactRouter
- Vue：vue-router



vue-router 是 Vue.js 官方的路由插件，它和 vue.js 是深度集成的，适合用于构建单页面应用



vue-router 是基于路由和组件的，路由用于设定访问路径, 将路径和组件映射起来，在 vue-router 的单页面应用中, 页面路径的改变就是组件的切换



### 安装 vue-router



直接使用 npm 来安装路由即可



1. 安装 vue-router



```
npm install vue-router --save
```



1. 在模块化工程中使用



因为 vue-router 是一个插件，所以可以通过 `Vue.use()` 来安装路由功能



1. 1. 导入路由对象，并且调用 Vue.use(VueRouter)
   2. 创建路由实例，并且传入路由映射配置
   3. 在 Vue 实例中挂载创建的路由实例



### 使用 vue-router



1. 创建路由组件



- 创建 router 实例



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582008050037-356ad576-cbe0-46d2-9145-5195e75bc290.png)



- 挂载到 Vue 实例中



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582008322840-e53d3ea3-a0fb-4d76-823f-ac278486328b.png)



1. 配置路由映射: 组件和路径映射关系



- 新建两个组件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582009386324-b865d78a-c13e-49b4-9ef7-f704c8b3c4d5.png)



- 为组件配置路由映射关系



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582009609319-06ab2850-d796-455f-8ee2-cca267cf78d2.png)



1. 使用路由: 通过`和`



- `: 该标签是一个 vue-router 中已经内置的组件, 它默认会被渲染成一个` 标签
- ``: 该标签会根据当前的路径，动态渲染出不同的组件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582009832304-fefdc237-7445-4d92-a83b-bbb2780fdbd8.png)



最终效果如下：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582010079056-7909b2c7-9807-4ef4-91aa-5a1a051e9dc9.png)



### 细节处理



#### 路由的默认路径



默认情况下, 进入网站的首页，我们希望 `` 渲染首页的内容，但是在上面的实现中，默认没有显示首页组件，必须让用户点击才可以



如何可以让路径默认跳到到首页，并且``渲染首页组件呢?



只需要多配置一个映射就可以了：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582010900763-9d1ab04a-b10e-48b5-bd00-1311edad14a2.png)



我们在 routes 中又配置了一个映射：

- path：根路径 `/`
- redirect：重定向，也就是将根路径重定向到 `/home` 的路径下



这样，打开页面时，就会默认显示首页的内容了



#### HTML5 的 History 模式



前面说过改变路径的方式有两种：

- URL 的 hash
- HTML5 的 history



默认情况下，Vue 路径的改变使用的是 URL 的 hash，这样显示出的页面的地址中有一个 `#` 号，不太美观：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582011120733-597e742c-a7cc-4faa-8605-b4837388c522.png)



可以使用 HTML5 的 history 模式来进行改变，进行如下配置即可：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582011255018-3d7b1ce9-76bb-48be-b9c9-eaf9b10469bd.png)



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582011237837-aac8bce6-ea55-41c6-a846-12dc0b6e9526.png)



### router-link 补充



在前面的 `` 中，我们只是使用了一个属性`:to`，用于指定跳转的路径



`` 还有一些其他属性：



- tag：tag 可以指定 `之后渲染成什么组件，默认是渲染为` 标签



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012121688-87862537-1d78-4f67-8b25-8afb49085442.png)



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012138835-87564fd3-fa6c-41c2-a9f4-c1a8109c3681.png)



- replace: replace 不会留下 history 记录，所以指定 replace 的情况下, 后退键返回不能返回到上一个页面中



```
<router-link to="/home" tag="button" replace>首页</router-link>
```



- active-class: 当``对应的路由匹配成功时，会自动给当前元素设置一个`router-link-active` 的class



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012337882-52d82010-2c2c-4524-b8ac-d274c4291eff.png)



设置 `active-class` 可以修改默认的名称：



```
<router-link to="/home" tag="button" replace active-class="active">首页</router-link>
```



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012526889-419e15a9-c555-45db-b778-7e4d954abf47.png)



在进行高亮显示的导航菜单或者底部 tabbar 时，会使用到该类，比如想设置按钮点击时变为红色：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012677201-e13633e2-2ca4-40a5-8803-1a98618167e4.png)



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012688408-2a5a20f7-55c2-4cda-8f62-be194de6dee9.png)



该 class 具体的名称也可以通过 router 实例的属性进行修改：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582012782822-8e96daaa-5cf4-45b5-af89-6946fcd4fda0.png)



但是通常不会修改类的属性, 会直接使用默认的 router-link-active 即可



### **路由代码跳转**

** **

有时候，页面的跳转可能需要执行对应的 JavaScript 代码，这个时候，就可以使用第二种跳转方式了

比如，我们将代码修改如下:



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582013546076-c7a32bd2-64fd-48c1-ad63-b6f8c1896ac5.png)



### 动态路由



在某些情况下，一个页面的 path 路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：

`/user/aaaa` 或 `/user/bbbb`，除了有前面的 `/user`之外，后面还跟上了用户的 ID



这种 path 和 Component 的匹配关系，称之为动态路由（也是路由传递数据的一种方式）



1. 在 `vue-router` 的路由路径中使用“动态路径参数”(dynamic segment) ：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582017769318-3808513e-7fd0-4fb4-b57f-c4f42ab7eeed.png)



1. 在组件中手动绑定一个用户 ID：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582018151757-b73ed16b-1c3b-4a94-ad73-f351793df7d2.png)



1. 更新 `User` 的模板，输出当前用户的 ID：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582017894093-3ca81076-b6c3-4e02-8ab0-493c6f997591.png)



1. 查看显示效果：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582017931254-34890aef-b389-4179-a5ad-493f7e1d1f51.png)



### 路由的懒加载



#### 认识路由的懒加载



当打包构建应用时，Javascript 包会变得非常大，影响页面加载，如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了



为了实现这种效果，我们可以使用路由的懒加载



路由懒加载的主要作用就是将路由对应的组件打包成一个个的 js 代码块，只有在这个路由被访问到的时候，才加载对应的组件



#### 懒加载的三种方式



1. 结合 Vue 的异步组件和 Webpack 的代码分析



```
const Home = resolve => { require.ensure(['../components/Home.vue'], () => { resolve(require('../components/Home.vue')) })};
```



1. AMD 写法



```
const About = resolve => require(['../components/About.vue'], resolve);
```



1. 在ES6中，可以用更加简单的写法来组织 Vue 异步组件和 Webpack 的代码分割



```
const Home = () => import('../components/Home.vue')
```



**路由懒加载的效果**

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582089079669-bc7d3fe7-be9c-4b82-8ed0-aeae36df29b8.png)**



## Vue-router 嵌套路由



嵌套路由是一个很常见的功能 ，比如在 home 页面中，我们希望通过 `/home/news` 和 `/home/message` 访问一些内容，一个路径映射一个组件，访问这两个路径也会分别渲染两个组件



路径和组件的关系如下:



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582089942199-7fa71333-4367-41aa-be85-43b759288799.png)



实现嵌套路由有两个步骤：



1. 创建对应的子组件，并且在路由映射中配置对应的子路由



- 定义两个子组件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582090298638-2e12641f-e596-499e-891e-655a09638fc5.png)



- 配置子组件的路由



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582090907257-0f46231c-62c0-4a9d-8aba-d2a7084ff8c5.png)



- 配置嵌套路由的默认路径



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582091066609-26b83948-1d11-498d-a281-2206861b743e.png)



1. 在父组件内部显示子组件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582091148250-6ff19d1f-1969-49a3-8a12-c7841005cb7b.png)



1. 查看显示效果



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582091301195-082bdccc-efaf-4f96-abb9-6ce0452bee20.png)

## Vue-router 参数传递



### 准备工作



为了演示传递参数，再创建一个组件，并且将其配置好

1. 创建新的组件 Profile.vue



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582093327545-c83c7bac-cfc4-40a5-a7dd-e28bbfe2a9cc.png)



1. 配置路由映射



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582093378275-24f6b3c4-6f2a-41d8-b949-6571b9a7c6da.png)



1. 添加跳转的``



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582093437718-f681ed59-2b7b-4fea-910f-25da22396c17.png)



### 传递参数的方式



传递参数主要有两种类型: params 和 query



- params
- - 配置路由格式：`/router/:id`
  - 传递的方式：在 path 后面跟上对应的值
  - 传递后形成的路径：`/router/123`，`/router/abc`



- query
- - 配置路由格式：`/router`
  - 传递的方式：对象中使用 query 的 key 作为传递方式
  - 传递后形成的路径：`/router?id=123`，`/router?id=abc`



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582093699105-4705164a-3d9a-4fae-8775-445e69ea5e5b.png)



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582093722754-2ea7219e-49b7-4d77-8011-1f609c9f8ad3.png)



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582093755280-86131e1b-a81b-45f9-aa70-d687c0e8efee.png)

**获取参数**

** **

获取参数是通过 *route* 对象获取的，在使用了 *v**u**e*−*r**o**u**t**e**r* 的应用中，路由对象会被注入每个组件中，赋值为 `*t**h**i**s*.route` ，并且当路由切换时，路由对象会被更新



**route 和 router** **的\****区别**

\* *

- *r**o**u**t**e**r* 为 *V**u**e**R**o**u**t**e**r* 实例，想要导航到不同 *U**R**L*，则使用 `router.push` 方法
- $route 为当前 router 跳转对象，里面可以获取 name、path、query、params 等



## Vue-router 导航守卫



在一个 SPA 应用中，如何改变网页的标题呢？



普通的修改方式：在每一个路由对应的组件 `.vue` 文件中，通过 mounted 声明周期函数，执行对应的代码进行修改



但是当页面比较多时，需要在多个页面执行类似的代码，所以这种方式不容易维护



更好的办法是使用导航守卫



### 什么是导航守卫



导航守卫主要用来监听路由的进入和离开，vue-router 提供了 beforeEach 和 afterEach 的钩子函数，它们会在路由即将改变前和改变后触发



### 导航守卫使用



我们可以利用 beforeEach 来完成标题的修改：



1. 在钩子当中利用 meta 来定义标题



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582110111670-bcd8a09a-0fc1-472f-ba3b-b4c3ba9562be.png)



1. 利用导航守卫，修改标题



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582110480182-658246e7-9404-4aa9-b161-8eeeee565ee0.png)



1. 查看修改效果



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582110669600-4abc9e8b-5036-4af9-bba1-59bfdff69203.png)



### 导航钩子的三个参数解析



- to: 即将要进入的目标的路由对象
- from: 当前导航即将要离开的路由对象
- next: 调用该方法后，才能进入下一个钩子



### 导航守卫补充



- 如果是后置钩子，也就是afterEach，不需要主动调用 next() 函数
- 上面使用的导航守卫，被称之为全局守卫，除此之外，还有路由独享的守卫、组件内的守卫



## keep-alive 



keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染



router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：



```
<keep-alive>
  <router-view>
    <!-- 所有路径匹配到的试图组件都会被缓存！ -->
  </router-view>
</keep-alive>
```



现在有这样一个需求：首页正正在显示的是被嵌套的消息路由，当我们点击其他页面，又重新点击首页时，让首页仍然显示被嵌套的消息路由



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582118488171-5efdf936-7362-4d46-885a-75c55dd804df.png)

1. 先取消嵌套路由的默认路径



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582118538781-95301643-5538-46f6-8d53-7a3d37acc412.png)



1. 在 App.vue 中使用 `包裹`



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582118555670-5b389542-a9c3-4ace-a9b3-d9e3dccc9c62.png)



1. 在 Home.vue 中记录离开之前的路径



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582118584898-331a2182-3a2b-41a8-b3e9-e7b216f3145e.png)



keep-alive 还有两个非常重要的属性:

- include - 字符串或正则表达，只有匹配的组件会被缓存
- exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存



让部分组件不缓存：



```
<keep-alive exclude="Profile,User"><router-view/></keep-alive>
```



# Vuex



## 认识 Vuex



### 什么是 Vuex



> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式

- Vuex 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
- Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能

### 状态管理

#### 什么是状态管理

简单理解：把需要多个组件共享的变量全部存储在一个对象里面，然后将这个对象放在顶层的 Vue 实例中，让其他组件可以使用，共享这个对象中的所有变量属性，并且是响应式的

#### 管理什么状态

- 用户的登录状态、用户名称、头像、地理位置信息等
- 商品的收藏、购物车中的物品等

#### 单界面的状态管理

在单个组件中进行状态管理是一件非常简单的事情，如图：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582268075935-f55da969-5ca7-4166-ae57-b1dd95054979.png)

- State：状态（姑且可以当做是 data 中的属性）
- View：视图层，可以针对 State 的变化，显示不同的信息
- Actions：用户的各种操作：点击、输入等，会导致状态的改变

**单界面状态管理的实现**

![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582271299552-6dd812be-aa80-4057-b615-f13a7eba2c10.png)



在这个案例中：

- counter 需要某种方式被记录下来，也就是 State
- counter 目前的值需要被显示在界面中，也就是我们的 View
- 界面发生某些操作时（这里是用户的点击，也可以是用户的 input），需要去更新状态，也就是 Actions

#### 多界面状态管理



Vue 已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？



多个视图都依赖同一个状态（一个状态改了，多个界面需要进行更新）



全局单例模式（大管家）



现在要做的就是将共享的状态抽取出来，交给大管家统一进行管理，之后每个试图按照规定进行访问和修改等操作，这就是 Vuex 的基本思想



Vuex 状态管理图例



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582271824071-2b4b9f3f-afd3-46a6-b982-20347c4cd66d.png)



### Vuex 的基本使用



**简单的案例**

** **

还是实现一下之前简单的案例：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582271915595-6cd5c146-e5a2-4098-8e98-bb19c37c166f.png)



首先，我们需要在某个地方存放我们的 Vuex 代码：

- 安装 Vuex：`npm i vuex --save`
- 创建一个文件夹 store，并且在其中创建一个 index.js 文件



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582272179678-30d39d12-958b-48f8-91f5-ef3caacbd4f7.png)



- 在 index.js 文件中写入如下代码



```
import Vue from 'vue'
import Vuex from 'vuex'

vue.use(Vuex)

const store = new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment(state) {
            state.count++
        },
        decrement(state) {
            state.count--
        }
    }
})

export default store
```



**挂载到 Vue 实例中**

** **

其次，我们让所有的 Vue 组件都可以使用这个 store 对象



来到 main.js 文件，导入 store 对象，并且放在 `new Vue` 中：



```
import Vue from 'vue'
import App from './App'
import router from './router'
import store from './store'

Vue.config.productionTip = false

new Vue({
    el: '#app',
    router,
    store,
    render: h => h(App)
})
```



此后，在其他 Vue 组件中，可以通过 `this.$store` 的方式，获取到 store 对象



**使用 Vuex 的 count**

** **

```
<template>
  <div class="test">
    <h2>当前计数：{{count}}</h2>
    <button @click="increment">+</button>
    <button @click="decrement">-</button>
  </div>
</template>

<script>
export default {
  name: 'Test',
  computed:{
    count(){
      return this.$store.state.count
    }
  },
  methods:{
    increment(){
      this.$store.commit('increment')
    },
    decrement(){
      this.$store.commit('decrement')
    }
  }
}
</script>
<style scoped>
</style>
```

** **

这就是使用 Vuex 最简单的方式了：

1. 提取出一个公共的 store 对象，用于保存在多个组件中共享的状态
2. 将 store 对象放置在 new Vue 对象中，这样可以保证在所有的组件中都可以使用到
3. 在其他组件中使用 store 对象中保存的状态即可
4. 1. 通过 `this.$store.state.属性` 的方式来访问状态
   2. 通过 `this.$store.commit(‘Mutations中方法’)` 来修改状态



注意事项：

我们通过提交 Mutations 的方式，而非直接改变 `store.state.count` ，这是因为 Vuex 可以更明确的追踪状态的变化，所以不要直接改变 `store.state.count` 的值。

** **

## Vuex 核心概念



### State 单一状态树



Vuex 提出使用单一状态树（Single Source of Truth），也可以翻译成单一数据源



如果状态信息是保存到多个 Store 对象中的，那么之后的管理和维护等等都会变得特别困难，所以 Vuex 使用了单一状态树来管理应用层级的全部状态



单一状态树能够让我们以最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护



### Getters



有时候，我们需要从 store 中获取一些 state 变异后的状态，则可以使用 getters



#### Getters 基本使用



比如，现在 Store 中有这样的学生信息：



```
const store = new Vuex.Store({
    state: {
        count: 0,
        students: [
            { id: 1001, name: 'lyy', age: 18 },
            { id: 1002, name: 'sss', age: 17 },
            { id: 1003, name: 'lin', age: 28 },
            { id: 1004, name: 'jack', age: 24 }
        ]
    }
})
```



现要求获取年龄小于20的学生个数，可以在 Store 中定义 getters：



```
getters: {
  // 获取年龄小于20的学生人数
  getAgeLess20Count(state) { 
    return state.students.filter(s => s.age < 20).length
  }
}
```

** **

之后，在各个组件中想要使用这个 getters，只需要：



```
<template>
  <div id="app">
    <h3>{{this.$store.getters.getAgeLess20Count}}</h3>
  </div>
</template>
```



#### Getters 作为参数

** **如果我们已经有了一个获取所有年龄小于20岁学生列表的 getters，那么可以这样来写：



```
getters: {
  // 获取年龄小于20的学生
  getAgeLess20(state) {
    return state.students.filter(s => s.age < 20)
  },
  // 获取年龄小于20的学生人数
  getAgeLess20Count(state, getters) {
    return getters.getAgeLess20.length
  }
}
```



#### Getters 传递参数

** **

getters 默认是不能传递参数的，如果希望传递参数，那么只能让 getters 本身返回另一个函数



比如上面的案例中，我们希望根据 ID 获取用户的信息：



```
getters: {
  // 根据id查找学生
  getStuByID(state) {
    return id => state.students.find(s => s.id === id)
  }
}
```

** **

在组件中使用：



```
<template>
  <div id="app">
    <h3>{{this.$store.getters.getStuByID(1002)}}</h3>
  </div>
</template>
```

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582347932353-cbac965a-8238-4eea-994d-c47638ef5cfe.png)**

** **

### Mutations 状态更新



Vuex 的 store 状态的更新唯一方式：提交 Mutations



#### Mutations 组成

** **

- 字符串的事件类型（type）
- 一个回调函数（handler），该回调函数的第一个参数就是 state



#### Mutations 的定义方式



```
mutations: {
  increment(state) {
    state.count++
  },
    decrement(state) {
      state.count--
    }
}
```



**通过** **Mutations** **更新**



```
methods:{
  increment(){
    this.$store.commit('increment')
  },
  decrement(){
    this.$store.commit('decrement')
  }
}
```



#### Mutations 传递参数



在通过 Mutations 更新数据的时候，有时候希望携带一些额外的参数，这种参数被称为 Mutations 的载荷(Payload)



比如之前的计数器案例，每次都是加减 1 ，现在想让加减的数字作为一个参数，传到 Mutations 的方法中：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582349982391-5c172deb-116e-4092-b1c5-7402194bdb6b.png)



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582349947884-a915c9d8-0135-4c7a-91aa-e9ea4cc3d665.png)



如果有很多参数需要传递，通常会以对象的形式传递，也就是 payload 是一个对象，再从对象中取出相关的信息



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582349027675-8191a3cf-22a4-4349-ab5d-95f0920b1c77.png)



#### Mutations 提交风格



上面的通过 commit 进行提交是一种普通的方式

Vue 还提供了另外一种风格, 它是一个包含 type 属性的对象



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582351555657-24c5e67d-93b3-4651-9644-4cc24695feb6.png)



Mutations 中的处理方式是将整个 commit 的对象作为 payload 使用, 所以代码没有改变, 依然如下:



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582351586259-bb44aa21-1e7a-4257-9b91-a0b847a63cb2.png)



#### Mutations 响应规则

** **

Vuex 的 store 中的 state 是响应式的， 当 state 中的数据发生改变时，Vue 组件会自动更新



这就要求我们必须遵守一些Vuex对应的规则：

- 提前在store中初始化好所需的属性
- 当给 state 中的对象添加新属性时，使用下面的方式：

1. 1. 使用 `Vue.set(obj, 'newProp', 123)`
   2. 用新对象给旧对象重新赋值



我们来看一个例子:



当我们点击更新信息时，界面并没有发生对应改变：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582361668512-a56fad4f-0e02-469d-853e-7b89a07d51ce.png)



以上代码给 state 中的对象添加新属性时，由于不是响应式添加，所以界面不会更新，要想让界面更新，可以使用一下方式：

** **

```
updateInfo(state, payload) {
  // state.info['height'] = payload.height
  // 方式一：Vue.set()
  // Vue.set(state.info, 'height', payload.height)
  // 方式二：给 info 赋值一个新的对象
  state.info = {...state.info, 'height': payload.height }
}
```

** **

此时，点击修改信息按钮后，界面和 info 里面的信息都会更新：

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582361905342-8cfa2308-161d-416b-a2b0-7f48c23ebe9f.png)**

** **

#### Mutations 常量类型



在 Mutations 中， 我们定义了很多事件类型（也就是其中的方法名称），当我们的项目不断增大时，会出现：

- Vuex 管理的状态越来越多，需要更新状态的情况越来越多
- Mutations 中的方法越来越多，使用者需要花费大量的经历去记住这些方法，甚至是多个文件间来回切换，查看方法名称，甚至出现写错的情况



如何避免上述的问题呢?



在各种 Flux 实现中，一种很常见的方案是：

- 使用常量替代 Mutations 事件的类型
- 将这些常量放在一个单独的文件中，方便管理以及让整个 app 所有的事件类型一目了然



具体操作：

1. 创建一个文件: mutations-types.js，并且在其中定义我们的常量



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582363101213-dbcc634b-5459-4828-9345-06b98028eb6d.png)



定义常量时，我们可以使用 ES2015 中的风格，使用一个常量来作为函数的名称

1. 使用定义的常量

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582363229840-c4b1a773-a0b1-4f34-b4d9-f0d26332e5b4.png)

### Actions



通常情况下，Vuex 要求 Mutations 中的方法必须是同步方法，因为当我们使用 devtools 时，devtools 可以帮助我们捕捉 Mutations 的快照，但如果是异步操作, 那么 devtools 将不能很好的追踪这个操作什么时候会被完成



比如之前的代码，当执行修改信息操作时，devtools 中会有如下信息：





![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582366495229-651290b9-a0d1-4c2b-8e0d-0f3189c61114.png)



但是，如果 Vuex 中的代码使用了异步函数：



```
mutations: {
  [types.UPDATE_INFO](state, payload) {
    setTimeout(() => {
      state.info = {...state.info, 'height': payload.height }
    }, 1000);
  }
}
```



这时会发现 state 中的 info 数据一直没有被改变：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582367932792-4712a4fb-e38f-4385-92fa-2543ccd620ff.png)



这是因为 devtools 无法追踪到异步操作



虽然强调不要再 Mutations 中进行异步操作，但某些情况,，又确实希望在 Vuex 中进行一些异步操作，比如网络请求，这时可以使用 Action



Action 类似于 Mutations，是用来代替 Mutations 进行异步操作的



在 Action 中，可以将异步操作放在一个 Promise 中，并且在成功或者失败后，调用对应的 resolve 或 reject：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582370522597-ac244103-a3a2-4fc7-aae1-c0a63d06f660.png)

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582370603653-5a3f155d-4a89-4f56-a028-5b6824d798ba.png)**

** **

### Modules



#### Modules 基本使用



Modules 是模块的意思，为什么在Vuex中我们要使用模块呢?



Vue 使用单一状态树，意味着很多状态都会交给 Vuex 来管理，当应用变得非常复杂时，store 对象就有可能变得相当臃肿，为了解决这个问题，Vuex 允许我们将 store 分割成模块（Module）， 每个模块拥有自己的 state、mutations、actions、getters 等



我们按照什么样的方式来组织模块呢?

** **

```
const ModuleA = {
  state:{},
  mutations:{},
  actions:{},
  getters:{}
}

const ModuleB = {
  state:{},
  mutations:{},
  actions:{},
  getters:{}
}

const store = new Vuex.Store({
  modules:{
    a:ModuleA,
    b:ModuleB
  }
})

store.state.a // ModuleA 的状态
store.state.b // ModuleB 的状态
```

** **

#### Modules 中的 state 



要想知道如何调用 Modules 中的 state，需要先了解一下 Modules 中的 module 真实位置



其实，在 store 实例的 modules 中定义的 a 和 b 会被放到 store 的 state 中：

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582378432016-2bb52a06-1c64-4350-9988-4944874427f5.png)**

** **

在 devtools 中也能看到：

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582378148240-9fc84a8f-a9d6-4690-9cb3-929e02945c81.png)**



既然 Module 被放到了 store 的 state 中，那么在其他组件中就可以使用 `this.$store.state` 来调用了：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582378755885-761628fd-b7bc-4fe7-9ee0-87da1610b50d.png)



**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582378789885-0ecb8778-2af0-4084-a810-def45a06ccf0.png)**

** **

#### Modules 中的 mutations



虽然 mutations 是定义在模块中的，但是在组件中提交时还是使用：`this.$store.commit`

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582379764558-651f8939-2758-4b31-a47c-ec914bc906df.png)**

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582379792441-672623e5-af3a-4f11-90c4-5ab4bc9b20ce.png)**

** **

#### Modules 中的 getters



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582380686127-63e985e7-d3e4-4db4-b349-0e05f6a58ec4.png)



#### Modules 中的 actions



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582381159877-d28ce9e4-8e7a-4227-ae7d-ea726a8b493f.png)



## 项目结构



当 Vuex 帮助我们管理过多的内容时，好的项目结构可以让我们的代码更加清晰：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582382365435-02e31dd4-49cf-4120-8dfd-e1860a960456.png)



# 网络模块封装



## 网络模块的选择

### 传统的 Ajax

- 传统的 Ajax 基于 XMLHttpRequest(XHR)
- 之所以不用它，是因为它配置和调用方式等非常混乱，编码起来看起来令人十分头疼
- 真实开发中很少直接使用传统的 Ajax ， 而是使用 jQuery-Ajax

### jQuery-Ajax

- jQuery-Ajax 相对于传统的 Ajax 非常好用
- 之所以不用它，是因为 jQuery 是一个重量级的框架，代码有 1w+ 行，而 Vue 的代码才 1w+ 行，所以没必要为了网络请求，特意引用一个 jQuery

### Vue-resource

- 官方在 Vue1.x 的时候, 推出了 Vue-resource
- Vue-resource 的体积相对于 jQuery 小很多
- 之所以不用它，是因为在 Vue2.0 推出后，Vue 的作者就在 GitHub 的 Issues 中说明了去掉 vue-resource，并且以后也不会再更新，意味着以后 vue-reource 不再支持新的 Vue 版本，也不会再继续更新和维护，对以后的项目开发和维护都存在很大的隐患



### axios



- 在说明不再继续更新和维护 vue-resource 的同时，作者还推荐了一个框架：axios
- axios有非常多的优点, 并且用起来也非常方便



## axios



### axios 功能特点



- 在浏览器中发送 XMLHttpRequests 请求
- 在 node.js 中发送 http请求
- 支持 Promise API
- 拦截请求和响应
- 转换请求和响应数据



### axios 请求方式



- `axios(config)`
- `axios.request(config)`
- `axios.get(url[, config])`
- `axios.delete(url[, config])`
- `axios.head(url[, config])`
- `axios.post(url[, data[, config]])`
- `axios.put(url[, data[, config]])`
- `axios.patch(url[, data[, config]])`



**发送 get 请求**



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582433664374-0556e0b3-c255-405f-913f-98f0824288bf.png)

**发送并发请求**

** **

使用 `axios.all`，可以放入多个请求的数组



`axios.all([])` 返回的结果是一个数组，使用 `axios.spread` 可将数组 [res1,res2] 展开为 res1, res2



```
axios.all([axios.get('http://123.207.32.32:8000/home/multidata'),
        axios.get('http://123.207.32.32:8000/home/data', { params: { type: 'sell', page: 1 } })
    ])
    .then(axios.spread((res1, res2) => {
        console.log(res1);
        console.log(res2);
    }))
```



### 全局配置



在开发中，可能很多参数都是固定的，这个时候，我们可以进行一些抽取，也可以利用 axios 的全局配置



```
axios.defaults.baseURL = '123.207.32.32:8000'
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582437880616-1a9e48c6-8804-4a5e-a743-1d26f0f507f9.png)**

** **

### axios 实例



为什么要创建 axios 的实例呢?



当我们从 axios 模块中导入对象时，使用的实例是默认的实例，当给该实例设置一些默认配置时，这些配置就被固定下来了，但是后续开发中，某些配置可能会不太一样，比如某些请求需要使用特定的 baseURL 或者 timeout 或者content-Type 等，这时我们就可以创建新的实例，并且传入属于该实例的配置信息



```
// 创建新的实例
const axiosInstance = axios.create({
    baseURL: 'http://123.207.32.32:8000',
    timeout: 5000,
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
})

// 发送网络请求
axiosInstance({
    url: '/category',
    method: 'get'
}).then(res => {
    console.log(res);
}).catch(err => {
    console.log(err);
})
```

** **

### axios 封装

** **

- 封装 axios

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582445119331-4c71c374-c6e5-4af2-a38b-a30314f9bb5e.png)**

** **

- 请求 axios

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582445134119-a368b6eb-3b7a-4b49-9cc3-9ff347a17f6b.png)**

** **

#### 拦截器



axios 提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理

如何使用拦截器呢？

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582446646801-f8e2ba43-dfa2-40e5-86ab-465c1b044520.png)**

** **

**拦截器中都做什么呢？**

** **

请求拦截可以做到的事情：

** **

**![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582446691988-b7c2412e-c42a-4035-8ae6-3284370afaaa.png)**

** **请求拦截中错误拦截较少，通常都是配置相关的拦截

比如请求超时，可以将页面跳转到一个错误页面中



响应拦截中完成的事情：

响应的成功拦截中，主要是对数据进行过滤



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582446751331-9094e25b-7eea-47f1-8ba1-fe31307ebd7b.png)



响应的失败拦截中，可以根据 status 判断报错的错误码，跳转到不同的错误提示页面：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582446787640-8c727e6d-4ba3-44cf-8250-83fbd9c937de.png)

** **

# ES6 补充 



## JS 高阶函数：filter、map、reduce



```
<script>
  const nums = [56, 87, 165, 574, 6, 94, 654, 124, 75, 452]
  // 现有一个数组nums，要求：
  // 1.选出数组中大于100的数字，保存到新数组newNums中
  // 2.新数组newNums中的元素乘以2，再保存到新数组newNums2中
  // 3.将数组newNums2中的所有元素加起来，保存到total变量中

  // 1. 使用filter过滤元素
  // 遍历数组nums，将n依次传入，将布尔值为true的值保存到一个新的数组中，最后返回这个数组
  let newNums = nums.filter(function(n) {
    return n > 100
  })
  console.log(newNums)
  // 2.使用map处理数组内的所有元素
  let newNums2 = newNums.map(function(n) {
    return n * 2
  })
  console.log(newNums2)
  // 3.使用reduce对数组中所有内容汇总
  let total = newNums2.reduce(function(preValue, n) {
    return preValue + n
  }, 0)
  console.log(total)

  // 简便写法
  // 1.链式调用
  let total2 = nums.filter(function(n) {
    return n > 100
  }).map(function(n) {
    return n * 2
  }).reduce(function(preValue, n) {
    return preValue + n
  }, 0)
  console.log(total2)

  // 2.链式调用的箭头函数方式
  let total3 = nums.filter(n => n > 100).map(n => n * 2).reduce((preValue, n) => preValue + n)
  console.log(total3)
</script>
```



## Promise



Promise 是 ES6 中一个非常重要和好用的特性，是异步编程的一种解决方案



通常在网络请求时，我们会处理异步事件，因为不能立即拿到结果，所以往往会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去



如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦，但当网络请求非常复杂时，就会出现回调地狱



### 网络请求的回调地狱



我们来考虑下面的场景：

- 通过一个 url1 从服务器加载一个数据 data1，data1 中包含了下一个请求的 url2
- 再通过 data1 取出 url2，从服务器加载数据 data2，data2 中包含了下一个请求的 url3
- 再通过 data2 取出 url3，从服务器加载数据 data3，data3 中包含了下一个请求的 url4
- 最后发送网络请求 url4，获取最终的数据 data4



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582191458688-81f4abf3-2f27-4151-84a0-6ade6c60bee0.png)



正常情况下，上面的代码不会有什么问题，可以正常运行，并且获取我们想要的结果



但是，这样的代码难看而且不容易维护



我们期望的是以一种更加优雅的方式来进行这种异步操作：使用 Promise



### 定时器的异步事件



用一个定时器来模拟异步事件：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582191628474-ed558999-2f5e-4a2b-96a2-ffcf1f5419ef.png)



假设下面的 data 是从网络上 1 秒后请求的数据，`console.log` 就是我们的处理方式



这是过去的处理方式，我们将它换成 Promise 代码：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582191719384-82a329cd-a683-4a00-836f-ef6eb6b61472.png)



这个例子会让我们感觉使用 Promise 有些多此一举，因为下面的 Promise 代码明显比上面的代码看起来还要复杂



**定时器异步事件解析**



我们先来认认真真的读一读这个程序到底做了什么？



- `new Promise` 创建了一个 Promise 对象
- 小括号中 `((resolve, reject) => {})` 是一个箭头函数
- - 在创建 Promise 时，传入的这个箭头函数是固定的（一般我们都会这样写）
  - resolve 和 reject 也是函数，通常情况下，会根据请求数据的成功和失败来决定调用哪一个
- - - 如果是成功的，通常会调用 `resolve(messsage)`，这时，后续的 then 会被回调
    - 如果是失败的，通常会调用 `reject(error)`，这时，后续的 catch 会被回调



### Promise 三种状态



当开发中有异步操作时，可以给异步操作包装一个 Promise，异步操作之后会有三种状态：



- pending：等待状态，比如正在进行网络请求，或者定时器没有到时间
- fulfill：满足状态，当我们主动回调了 resolve 时，就处于该状态，并且会回调 `.then()`
- reject：拒绝状态，当我们主动回调了 reject 时，就处于该状态，并且会回调 `.catch()`



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582201313661-c09fd3be-9d67-4117-9d99-358b738cdde0.png)



以上代码的另一种写法：



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582201135894-3e755fea-c26f-4460-95c9-8e811db56e43.png)



### Primose 的链式调用



```
<script>
  // promise 链式调用
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Hello World')
    }, 1000)
  }).then(data => {
    console.log(data) // Hello World
    return Promise.resolve(data + '111')
  }).then(data => {
    console.log(data) // Hello World111
    return Promise.resolve(data + '222')
  }).then(data => {
    console.log(data) // Hello World111222
    return Promise.reject(data + 'error')
  }).then(data => {
    console.log(data) // 这里代码不会执行，没有输出
    return Promise.resolve(data + '333')
  }).catch(data => {
    console.log(data) // Hello World111222error
    return Promise.resolve(data + '444')
  }).then(data => {
    console.log(data) // Hello World111222error444
  })
</script>
```

**链式调用简写**

将数据直接包装成 Promise.resolve，在 then 中直接返回：

```
<script>
  // promise 链式调用简写
 new Promise((resolve, reject) => {
  setTimeout(() => {
        resolve('Hello World')
    }, 1000)
  }).then(data => {
    console.log(data) // Hello World
    return data + '111'
  }).then(data => {
    console.log(data) // Hello World111
    return data + '222'
  }).then(data => {
    console.log(data) // Hello World111222
    return Promise.reject(data + 'error')
  }).then(data => {
    console.log(data) // 这里代码不会执行，没有输出
    return data + '333'
  }).catch(data => {
    console.log(data) // Hello World111222error
    return data + '444'
  }).then(data => {
    console.log(data) // Hello World111222error444
  })
</script>
```

### promise 的 all 方法的使用

```
<script>
  // Promise 的 all 方法使用
  Promise.all([
    new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve({
          name: 'lyy',
          age: 18
        })
      }, 1000)
    }),
    new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve({
          name: 'sss',
          age: 17
        })
      }, 2000)
    })
  ]).then(results => {
    console.log(results);
  })
</script>
```



![图片.png](https://cdn.nlark.com/yuque/0/2020/png/335089/1582206639895-8a439a5a-d660-46fa-9176-f54f9f0e9066.png)