### 01.var、let、const

1.变量提升：var存在变量提升，let、const不存在

```
console.log(name) // undefined
var name = "jack"

console.log(age) //Cannot access 'age' before initialization
let age = 12
```

2.重复定义：var可以重复定义，let、const不可以

3.暂时性死区：let声明会形成暂时性死区

>暂时性死区相当于一个封闭的作用域，不能在这个作用域中声明变量前使用变量，否则会报错

4.块级作用域：var声明的变量没有块级作用域、let、const在块级作用域有效

```
if(true) let a = 5 // 报错
```

5.挂载window：var声明的全局变量会挂载在window上（弊端：全局变量和顶层对象挂钩），而let和const不会

6.修改值：var、let声明的变量值可修改，const不可修改，用来声明常量

>那么如何使对象不可变？使用递归Object.freeze()

7.先声明后赋值：var、let可以先声明变量，后赋值，const不行

### 02.变量的结构赋值

1.理解：

* 从对象或数组中提取数据, 并赋值给变量(多个)

2.对象的解构赋值：

* 以前我们获取对象属性值的方式

```
let obj = {name : 'kobe', age : 39};
let name = obj.name;
let age = obj.age;
console.log(name, age);

function person(p) {//不用解构赋值
	console.log(p.name, p.age);
}
person(obj);
```

* 使用对象解构赋值

```
let {name, age} = {name : 'kobe', age : 39};
console.log(name, age);

function person1({name, age}) {
	console.log(name, age);
}
person1(obj);
```

3.数组的解构赋值

```
let arr = ['abc', 23, true];
let [a, b, c, d] = arr;
console.log(a, b, c, d); // 'abc', 23, true, undefined
```

解构的默认值是惰性的

```
let [a = foo()] = [1] // 不会打印123

function foo() {
	console.log(123)
}
```



### 03.模板字符串

1.模板字符串 : 简化字符串的拼接

* 模板字符串必须用 `` 包含

* 变化的部分使用${xxx}定义

```
let obj = {
    name : 'anverson',
    age : 41
};
// 传统字符串拼接
console.log('我叫:' + obj.name + ', 我的年龄是：' + obj.age);
// 模板字符串拼接
console.log(`我叫:${obj.name}, 我的年龄是：${obj.age}`);
```

### 04.字符串，数字的扩展

1.字符串的扩展

* includes(str)：判断是否包含指定的字符串，返回布尔值
* startWith(str)：判断是否以指定字符串开头，返回布尔值
* endWith(str)：判断是否以指定字符串结尾，返回布尔值
* repeat(count)：重复指定次数，返回新字符串

```
let str = 'abc'
console.log(str.includes("a")) // true
console.log(str.startsWith("a")) // true
console.log(str.endsWith("c")) // true
console.log(str.repeat(3)) // "abcabcabc"
```

2.数值的扩展

* 二进制与八进制数值表示法：二进制用0b，八进制用0o

```
console.log(0b1010)  // 10
cosnole.log(0o56) // 46
```

* Number.isFinite(i)：判断是否是有限大的数
* Number.isNaN(I)：判断是否是NaN
* Number.isInteger(I)：判断是否是NaN
* Number.parseInt(I)：将字符串转换为对应的数值
* Math.trunc(i)：去除小数部分

```
console.log(Number.isFinite(Infinity)) // false
console.log(Number.isNaN(NaN)) // true
console.log(Number.isInteger(2)) // true
console.log(Number.parseInt("123NaN")) // 123
console.log(Math.trunc(12.234)) // 12
```

### 05.数组方法

#### 15.1.ES5中的数组遍历方式

```js
let arr = [1, 2, 3, 2, 4]
```

#####  for循环

```js
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i])
}
```

后来语法有所升级，到 ES5 遍历数组的 API 多了起来，其中有 forEach、every、filter等，同样的功能可以用 forEach 、 map 、 every 等方法来实现。

#####  forEach() 没有返回值，只是针对每个元素调用func

```js
arr.forEach(function(elem, index, array) {
    if (arr[i] == 2) {
        continue
    }
    console.log(elem, index)
})
```

这个语法看起来要简洁很多，不需要通过索引去访问数组项，然而它的缺点也是很明显，不支持 break、continue 等。

```js
[1, 2, 3, 4, 5].forEach(function(i) {
    if (i === 2) {
        return;
    } else {
        console.log(i)
    }
})
```

这段代码的"本意"是从第一个元素开始遍历，遇到数组项 2 之后就结束遍历，不然打印出所遍历过的数值项。可是，事实让你大跌眼镜，因为它的输出是 1, 3, 4, 5。

注意

forEach 的代码块中不能使用 break、continue，它会抛出异常。

#####  map() 返回新的数组，每个元素为调用func的结果

```js
let result = arr.map(function(value) {
    value += 1
    console.log(value)
    return value
})
console.log(arr, result)
```

#####  filter() 返回符合func条件的元素数组

```js
let result = arr.filter(function(value) {
    console.log(value)
    return value == 2
})
console.log(arr, result)
```

#####  some() 返回boolean，判断是否有元素符合func条件

```js
let result = arr.some(function(value) {
    console.log(value)
    return value == 4
})
console.log(arr, result)
```

#####  every() 返回boolean，判断每个元素都符合func条件

```js
let result = arr.every(function(value) {
    console.log(value)
    return value == 2
})
console.log(arr, result)
```

同样完成刚才的目标，使用 every 遍历就可以做到 break 那样的效果，简单的说 return false 等同于 break，return true 等同于 continue。如果不写，默认是 return false。

注意

every 的代码块中不能使用 break、continue，它会抛出异常。

##### reduce() 接收一个函数作为累加器

```js
let sum = arr.reduce(function(prev, cur, index, array) {
    return prev + cur
}, 0)
console.log(sum)
let max = arr.reduce(function(prev, cur) {
    return Math.max(prev, cur)
})
console.log(max)
let res = arr.reduce(function(prev, cur) {
    prev.indexOf(cur) == -1 && prev.push(cur)
    return prev
}, [])
console.log(res)
```

有的同学会说，还有 for...in 可以遍历数组。

```js
for (var index in array) {
    console.log(array[index]);
}
```

说的没错，for...in 确实可以遍历数组，而且还支持 continue、break等功能，但是它真的没有瑕疵吗？如果 array 有自定义属性，你发现也会被遍历出来(显然不合理)。这是因为 for...in 是为遍历对象创造的（{a:1, b:2}），不是为数组设计的。

>注意
>
>for...in不能用于遍历数组。
>for...in代码块中不能有 return，不然会抛出异常。

#### 15.2.ES6中的数组遍历方式

##### Array.prototype.find()

find() 找出第一个满足条件返回true的元素，否则返回 undefined。

```js
let array = [5, 12, 8, 130, 44];

let found = array.find(function(element) {
    return element > 10;
});

console.log(found);
// 12
```

**语法：**`arr.find(callback[, thisArg])`

|   参数   |                             含义                             | 必选 |
| :------: | :----------------------------------------------------------: | :--: |
| callback | 在数组每一项上执行的函数，接收 3 个参数，element、index、array |  Y   |
| thisArg  |                  执行回调时用作 this 的对象                  |  N   |

##### Array.prototype.findIndex()

findIndex()方法找出第一个满足条件返回true的元素下标。否则返回-1。其实这个和 find() 是成对的，不同的是它返回的是索引而不是值。

```js
let array = [5, 12, 8, 130, 44];

let found = array.find(function(element) {
    return element > 10;
});

console.log(found);
// 1
```

**语法：**`arr.findIndex(callback[, thisArg])`

|   参数   |                             含义                             | 必选 |
| :------: | :----------------------------------------------------------: | :--: |
| callback | 在数组每一项上执行的函数，接收 3 个参数，element、index、array |  Y   |
| thisArg  |                  执行回调时用作 this 的对象                  |  N   |

##### for...of

```js
for (let val of [1, 2, 3]) {
    console.log(val);
}
// 1,2,3
```

上述代码中轻松实现了数组的遍历，乍一看没有绝对它有非常强大之处。我们不得不强调下，for...of 的来历和作用。

```js
for (variable of iterable) {

}
```

看下这个伪代码，of 后面是 iterable 既不是 for 循环规定的 array，也不是 for...in 规定的 Object，而是 iterable。如果查查 iterable 的含义就很直观的感受到 for...of 遍历的是一切可遍历的元素（数组、对象、集合）等，不要小瞧这个功能，因为在 ES6 中允许开发者自定义遍历，换句话说任何数据结构都可以自定义一个遍历，这个遍历是不能被 for、for...in 理解和实现的。很抽象吧？Iterator 是如何实现的这是ES6的新增语法，后面课程中 `Iterator` 一节会讲。

```js
for (let item of arr) {
    console.log(item)
}

for (let item of arr.values()) {
    console.log(item)
}

for (let item of arr.keys()) {
    console.log(item)
}

for (let [index, item] of arr.entries()) {
    console.log(index, item)
}
```

TIP

for...of是支持 break、continue、return的，所以在功能上非常贴近原生的 for。

##### values()

```
const arr = [0, 1, 2, 4]

for(let index of arr.keys()) { 
  console.log(index) // 0, 1, 2, 4
}
```

##### keys()

```
const arr = [0, 1, 2, 4]

for(let index of arr.keys()) { 
  console.log(index) // 0, 1, 2, 3
}
```

##### entries()

```
const arr = [0, 1, 2, 4]

for(let [index, item] of arr.entries()) {
  console.log(item + '--' + index)
}
```

#### 15.3.数组方法的扩展

##### 1.Array.from：将伪数组转换为数组

* 伪数组：选择器（querySelectAll，getElementByNames，getElementByClassNames...），arguments属性

ES5

```
let args = [].slice.call(arguments);
let imgs = [].slice.call(document.querySelectorAll('img'));
```

ES6

```
function fun () {
	Array.from(arguments).forEach((item) => {
		console.log(item)
	})
}
fun(1, 3, 45)
```

**惊喜**

难道 Array.from 只能用来将伪数组转换成数组吗，还有其他用法吗？这要来看下 Array.from 的几个参数：

**语法：**`Array.from(arrayLike[, mapFn[, thisArg]])`

|   参数    |                         含义                         | 必选 |
| :-------: | :--------------------------------------------------: | :--: |
| arrayLike |        想要转换成数组的伪数组对象或可迭代对象        |  Y   |
|   mapFn   | 如果指定了该参数，新数组中的每个元素会执行该回调函数 |  N   |
|  thisArg  |      可选参数，执行回调函数 mapFn 时 this 对象       |  N   |

看了这几个参数至少能看到 Array.from 还具备 map 的功能，比如我们想初始化一个长度为 5 的数组，每个数组元素默认为 1，之前的做法是这样的：

```js
let arr = Array(6).join(' ').split('').map(item => 1)
// [1,1,1,1,1]
```

这样写虽然也能实现，但是用起来比较繁琐，使用 Array.from 就会简洁很多。

```js
Array.from({
    length: 5
}, function() {
    return 1
})
```

这个代码看起来既简洁还容易理解

##### 2.Array.of()：将一系列值转换为数组

```
let arr = Array.of("jack", 12)
console.log(arr) ["jack", 12]
```

* 相比于new Array（）的方式创建数组，在只有一个数字的时候，new Array代表的是长度，而Array.of代表的是数组值。

```
new Array(3) // [ , , ]
Array.of(3) // [3]
```

##### 3.Array.prototype.fill()

fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

```js
let array = [1, 2, 3, 4]
array.fill(0, 1, 2)
// [1,0,3,4]
```

这个操作是将 array 数组的第二个元素（索引为1）到第三个元素（索引为2）内的数填充为 0，不包括第三个元素，所以结果是 [1, 0, 3, 4]

我们前面有提到用 Array.from 初始化为一个长度固定，元素为指定值的数组。如果用 fill 是否可以达到同样的效果呢？

```js
Array(5).fill(1)
// [1,1,1,1,1]
```

##### 4.Array.prototype.copyWithin()

在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

**语法：**`arr.copyWithin(target, start = 0, end = this.length)`

|  参数  |                             含义                             | 必选 |
| :----: | :----------------------------------------------------------: | :--: |
| target |          从该位置开始替换数据。如果为负值，表示倒数          |  Y   |
| start  | 从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算 |  N   |
|  end   | 到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算 |  N   |

```js
let arr = [1, 2, 3, 4, 5]
console.log(arr.copyWithin(1, 3))
// [1, 4, 5, 4, 5]
```

##### 5.Array.prototype.includes()

在 ES7 之前想判断数组中是否包含一个元素，基本可以这样写：

```js
console.log(array1.find(function(item) {
    return item === 2
}))
```

或者

```js
console.log(array1.filter(function(item) {
    return item === 2
}).length > 0)
```

ES7引入的Array.prototype.includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

**基本用法**

```js
const arr = ['es6', 'es7', 'es8']
console.log(arr.includes('es6')) // true
console.log(arr.includes('es9')) // false
```

**接收俩个参数**

要搜索的值和搜索的开始索引。第二个参数可选。从该索引处开始查找 searchElement。如果为负值，

```js
const arr = ['es6', 'es7', 'es8']
console.log(arr.includes('es7', 1)) // true
console.log(arr.includes('es7', 2)) // false
console.log(arr.includes('es7', -1)) // false
console.log(arr.includes('es7', -2)) // true
```

**与indexOf()比较**

```js
['a', 'b', 'c'].includes('a') //true
['a', 'b', 'c'].indexOf('a') > -1 //true

console.log(arr.indexOf('es7')) // 1
console.log(arr.indexOf('es7') > -1) // true
```

注意

只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些是无法判断的.

```js
const arr = [1, [2, 3], 4]
arr.includes([2, 3]) //false
arr.indexOf([2, 3]) //-1
```

**优缺点比较**

两者都是采用===的操作符来作比较的，不同之处在于：对于NaN的处理结果不同。我们知道js中 NaN === NaN 的结果是false, indexOf()也是这样处理的，但是includes()不是这样的。

```js
const demo = [1, NaN, 2, 3]
demo.indexOf(NaN) //-1
demo.includes(NaN) //true
```

总结

如果只想知道某个值是否在数组中存在，而并不关心它的索引位置，建议使用includes()。如果想获取一个值在数组中的位置，那么只能使用indexOf方法。

### 06.对象的扩展

#### 4.1.对象属性、方法简写

```
let x = 3;
let y = 5;
//普通额写法
let obj = {
    x : x,
    y : y,
    getPoint : function () {
    	return this.x + this.y
    }
};

//简化的写法
let obj = {
    x,
    y,
    getPoint () {
    	return this.x
    }
};
console.log(obj, obj.getPoint());
```

* 对象中的方法不适合使用箭头函数

#### 4.2.属性计算值

```
let s = 'school'
const obj = {
	[s] : '清华大学'
}
```

#### 4.3.Object.is(v1, v2)

判断两个数据是否完全相等

```
console.log(0 == -0) // true
console.log(NaN == NaN) // false
console.log(Object.is(0, -0)) // false
console.log(Object.is(NaN, NaN)) // true
```

* 跟全等号‘===’的区别是NaN和0的判断

#### 4.4.Object.assign(target, source1, source2...)

将源对象的属性复制到目标对象上

```
let obj = {}
let obj2 = {name: "jack", age: 12}
let obj3 = {salary: 30000}
Object.assign(obj, obj2, obj3)
console.log(obj) // {name: "jack", age: 12, salary: 30000}
```

#### 4.5.对象遍历

1.for...in（ES5）

```
const obj = {
	name: 'chh',
	age: 18,
	school: '清华'
}
for(let key in obj) {
	console.log(key, obj[key])
}
```

2.Object.keys()

```
Object.keys(obj).forEach(key => {
	console.log(key, obj[key])
})
```

3.Object.getOwnPropertyNames

```
Object.getOwnPropertyNames(obj).forEach(key => {
	console.log(key, obj[key])
})
```

4.Reflect.ownKeys()

```
Reflect.ownKeys(obj).forEach(key => {
	console.log(key, obj[key])
})
```

#### 4.6.拓展运算符

```
const obj = {
	name: 'chh',
	age: 18,
	school: '清华'
}

const obj2 = {
	emale: '10010',
	...obj
}
console.log(obj2)
```

#### 4.7.in

```
const obj = {
	name: 'chh',
	age: 18,
	school: '清华'
}
console.log(name in obj)

let arr = ['chh', 'yxc', 'rose']
console.log(1 in arr)  //true
```

* 数组中的in表示该索引位置是否有值

#### 4.8.深拷贝和浅拷贝

* 浅拷贝：会复制引用的拷贝方法称为浅拷贝
* 深拷贝：指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个

**浅拷贝**：   

1.数组

* slice
* concat

```
var arr = ['old', 1, true, null, undefined];

var new_arr = arr.concat();

new_arr[0] = 'new';

console.log(arr) // ["old", 1, true, null, undefined]
console.log(new_arr) // ["new", 1, true, null, undefined]

var new_arr = arr.slice();
```

2.对象

* Object.assign

深拷贝**：

* JSON.parse( JSON.stringify() )

>缺点：1.不能拷贝函数

**浅拷贝实现**

```
var shallowCopy = function(obj) {
    // 只拷贝对象
    if (typeof obj !== 'object') return;
    // 根据obj的类型判断是新建一个数组还是对象
    var newObj = obj instanceof Array ? [] : {};
    // 遍历obj，并且判断是obj的属性才拷贝
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
```

**深拷贝实现**

```
var deepCopy = function(obj) {
    if (typeof obj !== 'object') return;
    var newObj = obj instanceof Array ? [] : {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
        }
    }
    return newObj;
}
```

#### 4.9.面向对象和面向过程

面向过程：当我们要完成一个需求的时候，我们关心的是要把这个需求分为几个步骤，当这几个步骤实现了，这个需求就完成了

面向对象：我们会分析这个需求可以分为几个对象，这个对象具有哪些属性和方法

举个例子：

把一个大象装进冰箱

* 面向对象：1:打开冰箱，2:把冰箱装进冰箱，3:关闭冰箱
* 面向过程：1.分析需求有大象和冰箱两个对象，2.大象应该有体积的属性，装进冰箱的行为。冰箱应该有容量的属性，打开关闭的行为。3.基于这些属性判断大象是否达到条件，如果可以则打开装进冰箱，然后关闭。

### 07.箭头函数

1.基本语法

* 没有参数: () => console.log('xxxx')

* 一个参数: i => i+2

* 大于一个参数: (i,j) => i+j

* 函数体不用大括号: 默认返回结果

* 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回

```
let fun = function () {
	console.log('fun()');
};
fun();
//没有形参，并且函数体只有一条语句
let fun1 = () => console.log('fun1()');
fun1();
console.log(fun1());
//一个形参，并且函数体只有一条语句
let fun2 = x => x;
console.log(fun2(5));
//形参是一个以上
let fun3 = (x, y) => x + y;
console.log(fun3(25, 39));//64

//函数体有多条语句
let fun4 = (x, y) => {
	console.log(x, y);
	return x + y;
};
console.log(fun4(34, 48));//82
```

2.箭头函数和普通函数的区别：

* 简洁
* 箭头函数的this不是调用的时候决定的，箭头函数没有自己的this，而是会沿着作用域链向外层作用域查找，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。

```
let btn = document.getElementById('btn');
//没有箭头函数
btn.onclick = function () {
	console.log(this);//btn
};
//箭头函数
let btn2 = document.getElementById('btn2');

btn2.onclick = function () {
	console.log(this);//btn
};

let obj = {
    name : 'kobe',
    age : 39,
    getName : () => {
    	btn2.onclick = () => {
    		console.log(this);//window
    	};
    }
};
obj.getName();

function Person() {
    this.obj = {
        showThis : () => {
        	console.log(this);
        }
    }
}
let fun5 = new Person();
fun5.obj.showThis();
```

* 不能作为构造函数

```
const People = (name, age) => {
  this.name = name
  this.age = age
}

const people = new People('chh', 18)
//Uncaught TypeError: People is not a constructor
```

* 不可以使用argument对象

```
const fun = (name, age) => {
  console.log(arguments)
}

fun('chh', 12)
// index.html:18 Uncaught ReferenceError: arguments is not defined
```

### 08.扩展运算符和rest参数

1.rest(可变)参数：把逗号隔开的值组成一个数组（等号左边，形参）

* 用来取代arguments 但比arguments灵活,只能是最后部分形参参数

```
function fun(...values) {
	console.log(arguments);
//  arguments.forEach(function (item, index) {
//       console.log(item, index);
//  });
	
	Array.prototype.forEach.call(argument, (item, index) => {
		console.log(item, index)
	})
	
	console.log(values);
    values.forEach(function (item, index) {
    	console.log(item, index);
    })
}
fun(1,2,3);

const [x, ...arg] = [0, 1, 2]
```

2.扩展运算符：把数组或者类数组展开成用逗号隔开的值（等号右边，实参）

```
let arr1 = [1, 3, 5];
let arr2 = [2, ...arr1, 6];
arr2.push(...arr1);
```

### 09.函数的参数

#### 7.1.形参默认值

* 当不传入参数的时候默认使用形参里的默认值

ES5

```
//定义一个点的坐标
function Point(x, y) {
    this.x = x || 12;
    this.y = y || 12;
}
或
function Point(x, y) {
    this.x = x ? x : 12;
    this.y = y ? y : 12;
}
```

* 如果x和y为0的话，最终会被赋值12

ES6

```
//定义一个点的坐标
function Point(x = 12, y = 12) {
    this.x = x;
    this.y = y;
}
let point = new Point(25, 36);
console.log(point);
let p = new Point();
console.log(p);
```

* 参数的默认值最好放在最后面

#### 7.2.与解构赋值结合

```
function ajax(url, {
    body = '',
    method = 'GET',
    headers = {}
} = {}) {
    console.log(method)
}

ajax('http://www.imooc.com', {
    method: 'POST'
})
```

#### 7.3.length属性

函数指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。

```js
function foo(x = 1, y = 2, z = 3) {
    console.log(x, y)
}
console.log(foo.length)
// 0
```

#### 7.4.作用域

```
let x = 2
function foo1(x = 1, y = x) {
	console.log(y) // 1
}

function foo2(y = x) {
	console.log(y) // 2
}

function foo3(z = y) {
	console.log(z) // 报错
}
```

#### 7.5.函数的name属性

函数的name属性，返回该函数的函数名。

```js
function foo() {}

foo.name // "foo"
```

### 10.Promise对象

1.理解promise

* 代表了未来某个将要发生的事件(通常是一个异步操作)

2.promise的作用

* 将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱')

3.promise对象的3个状态

* pending: 初始化状态

* fullfilled: 成功状态

* rejected: 失败状态

4.promise使用基本步骤

* 创建promise对象

```
let promise = new Promise((resolve, reject) => {
   //初始化promise状态为 pending
   //执行异步操作
   if(异步操作成功) {
    	resolve(value);//修改promise的状态为fullfilled
   } else {
   		reject(errMsg);//修改promise的状态为rejected
   }
})
```

* 调用promise的then()

```
promise.then(function(
    result => console.log(result),
	errorMsg => alert(errorMsg)
))
```

* 练习demo01

```
let promise = new Promise((resolve, reject) => {
	// 初始化promise，状态为pending
	console.log("111")
	setTimeout(() => {
		console.log("333")
		resolve("resolve")
		reject("reject")
		console.log("结束")
	})
	
}).then((success) => {
	
    console.log("444" + success)
}, (error) => {
	
    console.log("555" + error)
})
console.log("222")
// 111，222，333，结束，444resolve
```

* 练习demo02

```
function getNew(url) {
  return promise = new Promise((resolve,  reject) => {
    let xhr = new XMLHttpRequest()
    xhr.open("GET", url)
    xhr.onreadystatechange = function() {
      if(xhr.readyState === 4) {
        if(xhr.status === 200) { // 请求成功
          resolve(xhr.responseText)
        }else {
          reject("暂无新闻内容")
        }
      }
    }
    xhr.send()
  })
}

getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/newId")
.then(res => {
  
  let url = JSON.parse(res).data.obj.url
  console.log(url)
  return getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/" + url)
})
.then(res => {
  console.log("获取评论内容")
  console.log(res)
})
```

### 11.symbol属性

1.理解：

* 一种新的基本数据类型

2.特点：

* Symbol属性对应的值是唯一的，解决命名冲突问题

* Symbol值不能与其他数据进行计算，包括同字符串拼串

* for in, for of遍历时不会遍历symbol属性。

3.使用：

* 调用Symbol函数得到symbol值

```
let symbol = Symbol();
let obj = {};
obj[symbol] = 'hello';
```

* 传参标识

```
let symbol = Symbol('one');
let symbol2 = Symbol('two');
console.log(symbol);// Symbol('one')
console.log(symbol2);// Symbol('two')
```

4.内置Symbol值

* 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。

​     \- Symbol.iterator

* 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)

### 12.iterator接口机制

1.理解：

* iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制

2.作用：

* 为各种数据结构，提供一个统一的、简便的访问接口；

* 使得数据结构的成员能够按某种次序排列

* ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。

3.工作原理：

* 创建一个指针对象，指向数据结构的起始位置。

* 第一次调用next方法，指针自动指向数据结构的第一个成员

* 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员

* 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}

* value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。

* 当遍历结束的时候返回的value值是undefined，done值为false

```
function myIteraor(arr) {
	let index = 0 //记录指针的位置
	return {
		next() {
			return {
				value[index++],
				done: index < arr.length - 1  ? false : true
			}
		}
	}
}
let arr = [1, 2, 3, 5, 2]

console.log(myIteraor.next(arr))
console.log(myIteraor.next(arr))
console.log(myIteraor.next(arr))
```

4.原生具备iterator接口的数据(可用for of遍历)

* Array、arguments、set容器、map容器、String...

``` 
let arr = [1, 2, 'abc']
for(let i of arr) {
	console.log(i) // 1, 2, 'abc'
}
let str = 'abc'
for(let j of str) {
	console.log(j) // a, b, c
}
function fun() {
	for(let i of arguments) {
		console.log(i) // 1, "fun", 44
	}
}
fun(1, "fun", 44)
let obj = {
	name: "jack",
	age: 12
}
for(let z of obj) {
	console.log(z) // obj is not iterable (obj 不是可迭代的)
}
```

### 13.Generator函数

1.理解：

* ES6提供的解决异步编程的方案之一

* Generator函数是一个状态机，内部封装了不同状态的数据，

* 用来生成遍历器对象

* 可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果

2.特点：

* function 与函数名之间有一个星号

* 内部用yield表达式来定义不同的状态

```
function* generatorExample(){
    let result = yield 'hello'; // 状态值为hello
    yield 'generator'; // 状态值为generator
}
```

* generator函数返回的是指针对象(接11节里iterator)，而不会执行函数内部逻辑

* 调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}

* 再次调用next方法会从上一次停止时的yield处开始，直到最后

* yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。

```
function* generatorFun() {
	console.log("开始执行generator函数")
	let yieldResult = yield "hello"
	console.log(...)
	console.log(yieldResult)
	console.log("执行中01")
	yield "my"
	console.log("执行中02")
	yield "baby"
	console.log("执行结束")
	
	return "come on" //可以指定第一个done为true的value值
}
let generatorObj = generatorFun()
console.log(generatorObj.next())
console.log(generatorObj.next())
console.log(generatorObj.next())
console.log(generatorObj.next())
console.log(generatorObj.next())
```

3.Generaltor函数应用

```
// 封装自己的ajax请求
function getNew(url, method, successFun, errorFun) {
  let xhr = new XMLHttpRequest()
  xhr.open(method, url)
  xhr.onreadystatechange = function() {
    if(xhr.readyState === 4) {
      if(xhr.status === 200 || xhr.status === 304) {
        let successText = JSON.parse(xhr.responseText)
        successFun(successText)
      }else {
        errorFun("error")
      }
    }else{
      errorFun("error")
    }
  }
  xhr.send()
}
function getNews(url) {
  getNew(url, "get", function(e) {
    let result = e.data.obj.url
    // 将url作为参数传入
    SX.next(result)
  }, function(e) {
    console.log(e)
  })
} 
function* getComment() {
  // 取到传入的url
  let url = yield
  getNews("https://www.easymock.com/mock/5f05d40904736119c8f374d7/ES6demo/newId")
  // 获取评论信息
  yield getNews(url)
}
let SX = getComment()
SX.next()
```

* 缺点：本质上还是没有脱离回调函数

### 14.async函数详解及应用

* 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作
* 本质：Generator的语法糖
* 语法

```
async function foo(){
  await 异步操作;
  await 异步操作；
}
```

* 特点：
  1. 返回的总是Promise对象，可以用then方法进行下一步操作
  2. 不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行
  3. async取代Generator函数的星号*，await取代Generator的yield

demo01:

```
async function test01() {
	return new Promise((resolve) => {
		setTimeout(resolve, 2000)
	})
}

async function test02() {
	console.log(new Date().toTimeString())
	await test01()
	console.log(new Date().toTimeString() + '...')
}

test02() // 输出时间字符串， 两秒后输出新时间字符串
```

demo02：async里await的返回值

```
function test03() {
	return "xxx"
}

async function test04() {
	let result = await test03()
	console.log(result) //"xxx"
	result = await Promise.resolve("success")
	console.log(result) //"success"
	result = await Promise.reject("error")
	console.log(result) //报错带"error"
}

test04()
```

demo03：获取新闻评论

```
function myAjax(option) {
  let xhr = new XMLHttpRequest()
  xhr.open(option.method, option.url)
  xhr.onreadystatechange = function() {
    if(xhr.readyState === 4) {
      if(xhr.status === 200 || xhr.status === 304) {
        option.success(xhr.responseText)
      }else{
        option.fail("error")
      }
    }
  }
  xhr.send()
}
async function getNew(url) {
  return new Promise((resolve, reject) => {
    myAjax({
        method: "GET",
        url,
        success: data => resolve(data),
        fail: error => reject(error)
    })
  })
}
async function sendXml() {
  let result = await getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/newId")
  let url = JSON.parse(result).data.obj.url
  let comment = await getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/" + url)
  console.log(JSON.parse(comment))
}
sendXml()
```

### 15.class类使用详解

#### 15.1.ES5实现继承

```
function Parent(name, age) {
	this.name = name
	this.age = age // 实例属性
	Parent.name = 32 // 静态属性
	Parent.getName = function() {
		return this.name
	}
}
Parent.prototype.getName = function() { // 实例方法
	return this.name 
}

function Child(name, age) {
	Parent.call(this, name, age)
}

// 使实例可访问父类的原型方法
Child.prototype = new Parent() 
Child.contructor = Parent

const person = new Child('chh', 12)
console.log(person) { name: 'chh', age: 12 }
console.log(Parent.getName()) // 32
```



#### 15.2.ES6实现继承

* 通过class实现类的继承
  * 通过constructor定义构造方法
  * 通过new来创建类的实例
  * 通过extends来实现类的继承
  * 通过super调用父类的构造方法

```
class Person {
	constructor(name, age) {
		this.name = name
		this.age = age
		this._sex = 0
	}
	// 必须用对象简写,保存在实例的原型中
	showName() {
		console.log(this.name)
	}
	get sex() {
		if(this._sex === 0) return 'male'
		if(this._sex === 1) return 'female'
		return 'error'
	}
	set sex(val) {
		if(val !== 0 && val !== 1) return
		this._sex = val
	}
}
let person = new Person("jack", 12)
console.log(person) // {name: "jack", age: 12}
person.showName() // "jack"

// 子类继承父类
class childPerson extends Person{
	constructor(name, age, salary) {
		super(name, age)
		this.salary = salary
	}
	// 类似于java方法的重写,不重写则用父类的原型的方法
	showName() {
		console.log("子类的方法")
		console.log(this.name)
	}
}
let person = new ChildPerson("jack", 13, 100000)
console.log(person)  // {name: "jack", age: 13, salary: 100000}
person.showName // jcak
```

### 16.Set，Map容器

1.Set容器：无序不可重复的多个value的集合体

* Set(array)
* add(value)
* delete(value)
* has(value)
* clear()
* size

```
let setArr = new Set([1, 4, 2, 3, 4, 3, 5])
console.log(setArr) // {1, 4, 2, 3, 5, size: 5}
setArr.add(2) // 不变
setArr.add(7) // {1, 4, 2, 3, 5, 7, size: 6}
setArr.delete(2) // {1, 4, 3, 5, 7, size: 5}
setArr.has(1) // true
setArr.clear() // {size: 0}
```

2.Map容器：无序的key不重复的多个key-value的集合体

* Map(array)
* set(key, value)
* get(key)
* delete(key)
* has(key)
* clear()
* size

```
let setArr = new Map([["name", "jack"],["age", 12]])
console.log(setArr) // {"name" => "jack", "age" => 12, size: 2}
setArr.set("address", "beijin") // {"name" => "jack", "age" => 12, "address" => "beijin", size: 3}
setArr.get("name") // "jack"
setArr.delete("name") // {"age" => 12, "address" => "beijin", size: 2}
setArr.has("address") // true
setArr.clear() // {size: 0}
```

### 17.ES7

1.指数运算符（幂）： **

```
console.log(3 ** 3) // 27
```

2.Array.prototype.includes(value)

```
let arr = [1, 4, "tom"]
console.log(arr.includes("tom")) // true =
```
