### 01.var、let、const

1.变量提升：var存在变量提升，let、const不存在

```
console.log(name) // undefined
var name = "jack"

console.log(age) //Cannot access 'age' before initialization
let age = 12
```

2.重复定义：var可以重复定义，let、const不可以

3.块级作用域：var声明的变量没有块级作用域的概念、let、const在块级作用域有效

4.修改值：var、let声明的变量值可修改，const不可修改，用来声明常量

5.挂载window：var声明的全局变量会挂载在window上，而let和const不会

### 02.变量的结构赋值

1.理解：

* 从对象或数组中提取数据, 并赋值给变量(多个)

2.对象的解构赋值：

* 以前我们获取对象属性值的方式

```
let obj = {name : 'kobe', age : 39};
let name = obj.name;
let age = obj.age;
console.log(name, age);

function person(p) {//不用解构赋值
	console.log(p.name, p.age);
}
person(obj);
```

* 使用对象解构赋值

```
let {name, age} = {name : 'kobe', age : 39};
console.log(name, age);

function person1({name, age}) {
	console.log(name, age);
}
person1(obj);
```

3.数组的解构赋值

```
let arr = ['abc', 23, true];
let [a, b, c, d] = arr;
console.log(a, b, c, d); // 'abc', 23, true, undefined
```

### 03.模板字符串

1.模板字符串 : 简化字符串的拼接

* 模板字符串必须用 `` 包含

* 变化的部分使用${xxx}定义

```
let obj = {
    name : 'anverson',
    age : 41
};
// 传统字符串拼接
console.log('我叫:' + obj.name + ', 我的年龄是：' + obj.age);
// 模板字符串拼接
console.log(`我叫:${obj.name}, 我的年龄是：${obj.age}`);
```

### 04.对象的简写形式

1.省略同名的属性值

```
let x = 3;
let y = 5;
//普通额写法
let obj = {
    x : x,
    y : y,
    getPoint : function () {
    	return this.x + this.y
    }
};

//简化的写法
let obj = {
    x,
    y,
    getPoint () {
    	return this.x
    }
};
console.log(obj, obj.getPoint());
```

### 05.箭头函数

1.基本语法

* 没有参数: () => console.log('xxxx')

* 一个参数: i => i+2

* 大于一个参数: (i,j) => i+j

* 函数体不用大括号: 默认返回结果

* 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回

```
let fun = function () {
	console.log('fun()');
};
fun();
//没有形参，并且函数体只有一条语句
let fun1 = () => console.log('fun1()');
fun1();
console.log(fun1());
//一个形参，并且函数体只有一条语句
let fun2 = x => x;
console.log(fun2(5));
//形参是一个以上
let fun3 = (x, y) => x + y;
console.log(fun3(25, 39));//64

//函数体有多条语句
let fun4 = (x, y) => {
	console.log(x, y);
	return x + y;
};
console.log(fun4(34, 48));//82
```

2.箭头函数和普通函数的区别：

* 简洁

* 箭头函数的this不是调用的时候决定的，箭头函数没有自己的this，而是会沿着作用域链向外层作用域查找，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。

```
let btn = document.getElementById('btn');
//没有箭头函数
btn.onclick = function () {
	console.log(this);//btn
};
//箭头函数
let btn2 = document.getElementById('btn2');

btn2.onclick = function () {
	console.log(this);//btn
};

let obj = {
    name : 'kobe',
    age : 39,
    getName : () => {
    	btn2.onclick = () => {
    		console.log(this);//window
    	};
    }
};
obj.getName();

function Person() {
    this.obj = {
        showThis : () => {
        	console.log(this);
        }
    }
}
let fun5 = new Person();
fun5.obj.showThis();
```

### 06.三点运算符

1.rest(可变)参数

* 用来取代arguments 但比arguments灵活,只能是最后部分形参参数

```
function fun(...values) {
	console.log(arguments);
//  arguments.forEach(function (item, index) {
//       console.log(item, index);
//  });
	console.log(values);
    values.forEach(function (item, index) {
    	console.log(item, index);
    })
}
fun(1,2,3);
```

2.扩展运算符

```
let arr1 = [1, 3, 5];
let arr2 = [2, ...arr1, 6];
arr2.push(...arr1);
```

### 07.形参默认值

* 当不传入参数的时候默认使用形参里的默认值

```
//定义一个点的坐标
function Point(x=12, y=12) {
    this.x = x;
    this.y = y;
}
let point = new Point(25, 36);
console.log(point);
let p = new Point();
console.log(p);
```

### 08.Promise对象

1.理解promise

* 代表了未来某个将要发生的事件(通常是一个异步操作)

2.promise的作用

* 将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱')

3.promise对象的3个状态

* pending: 初始化状态

* fullfilled: 成功状态

* rejected: 失败状态

4.promise使用基本步骤

* 创建promise对象

```
let promise = new Promise((resolve, reject) => {
   //初始化promise状态为 pending
   //执行异步操作
   if(异步操作成功) {
    	resolve(value);//修改promise的状态为fullfilled
   } else {
   		reject(errMsg);//修改promise的状态为rejected
   }
})
```

* 调用promise的then()

```
promise.then(function(
    result => console.log(result),
	errorMsg => alert(errorMsg)
))
```

* 练习demo01

```
let promise = new Promise((resolve, reject) => {
	// 初始化promise，状态为pending
	console.log("111")
	setTimeout(() => {
		console.log("333")
		resolve("resolve")
		reject("reject")
		console.log("结束")
	})
	
}).then((success) => {
	
    console.log("444" + success)
}, (error) => {
	
    console.log("555" + error)
})
console.log("222")
// 111，222，333，结束，444resolve
```

* 练习demo02

```
function getNew(url) {
  return promise = new Promise((resolve,  reject) => {
    let xhr = new XMLHttpRequest()
    xhr.open("GET", url)
    xhr.onreadystatechange = function() {
      if(xhr.readyState === 4) {
        if(xhr.status === 200) { // 请求成功
          resolve(xhr.responseText)
        }else {
          reject("暂无新闻内容")
        }
      }
    }
    xhr.send()
  })
}

getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/newId")
.then(res => {
  
  let url = JSON.parse(res).data.obj.url
  console.log(url)
  return getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/" + url)
})
.then(res => {
  console.log("获取评论内容")
  console.log(res)
})
```

### 09.symbol属性

1.理解：

* 一种新的基本数据类型

2.特点：

* Symbol属性对应的值是唯一的，解决命名冲突问题

* Symbol值不能与其他数据进行计算，包括同字符串拼串

* for in, for of遍历时不会遍历symbol属性。

3.使用：

* 调用Symbol函数得到symbol值

```
let symbol = Symbol();
let obj = {};
obj[symbol] = 'hello';
```

* 传参标识

```
let symbol = Symbol('one');
let symbol2 = Symbol('two');
console.log(symbol);// Symbol('one')
console.log(symbol2);// Symbol('two')
```

4.内置Symbol值

* 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。

​     \- Symbol.iterator

* 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)

### 10.iterator接口机制

1.理解：

* iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制

2.作用：

* 为各种数据结构，提供一个统一的、简便的访问接口；

* 使得数据结构的成员能够按某种次序排列

* ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。

3.工作原理：

* 创建一个指针对象，指向数据结构的起始位置。

* 第一次调用next方法，指针自动指向数据结构的第一个成员

* 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员

* 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}

* value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。

* 当遍历结束的时候返回的value值是undefined，done值为false

```
function myIteraor(arr) {
	let index = 0 //记录指针的位置
	return {
		next() {
			return {
				value[index++],
				done: index < arr.length - 1  ? false : true
			}
		}
	}
}
let arr = [1, 2, 3, 5, 2]

console.log(myIteraor.next(arr))
console.log(myIteraor.next(arr))
console.log(myIteraor.next(arr))
```

4.原生具备iterator接口的数据(可用for of遍历)

* Array、arguments、set容器、map容器、String...

``` 
let arr = [1, 2, 'abc']
for(let i of arr) {
	console.log(i) // 1, 2, 'abc'
}
let str = 'abc'
for(let j of str) {
	console.log(j) // a, b, c
}
function fun() {
	for(let i of arguments) {
		console.log(i) // 1, "fun", 44
	}
}
fun(1, "fun", 44)
let obj = {
	name: "jack",
	age: 12
}
for(let z of obj) {
	console.log(z) // obj is not iterable (obj 不是可迭代的)
}
```

### 11.Generator函数

1.理解：

* ES6提供的解决异步编程的方案之一

* Generator函数是一个状态机，内部封装了不同状态的数据，

* 用来生成遍历器对象

* 可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果

2.特点：

* function 与函数名之间有一个星号

* 内部用yield表达式来定义不同的状态

```
function* generatorExample(){
    let result = yield 'hello'; // 状态值为hello
    yield 'generator'; // 状态值为generator
}
```

* generator函数返回的是指针对象(接11节里iterator)，而不会执行函数内部逻辑

* 调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}

* 再次调用next方法会从上一次停止时的yield处开始，直到最后

* yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。

```
function* generatorFun() {
	console.log("开始执行generator函数")
	let yieldResult = yield "hello"
	console.log(...)
	console.log(yieldResult)
	console.log("执行中01")
	yield "my"
	console.log("执行中02")
	yield "baby"
	console.log("执行结束")
	
	return "come on" //可以指定第一个done为true的value值
}
let generatorObj = generatorFun()
console.log(generatorObj.next())
console.log(generatorObj.next())
console.log(generatorObj.next())
console.log(generatorObj.next())
console.log(generatorObj.next())
```

3.Generaltor函数应用

```
// 封装自己的ajax请求
function getNew(url, method, successFun, errorFun) {
  let xhr = new XMLHttpRequest()
  xhr.open(method, url)
  xhr.onreadystatechange = function() {
    if(xhr.readyState === 4) {
      if(xhr.status === 200 || xhr.status === 304) {
        let successText = JSON.parse(xhr.responseText)
        successFun(successText)
      }else {
        errorFun("error")
      }
    }else{
      errorFun("error")
    }
  }
  xhr.send()
}
function getNews(url) {
  getNew(url, "get", function(e) {
    let result = e.data.obj.url
    // 将url作为参数传入
    SX.next(result)
  }, function(e) {
    console.log(e)
  })
} 
function* getComment() {
  // 取到传入的url
  let url = yield
  getNews("https://www.easymock.com/mock/5f05d40904736119c8f374d7/ES6demo/newId")
  // 获取评论信息
  yield getNews(url)
}
let SX = getComment()
SX.next()
```

* 缺点：本质上还是没有脱离回调函数

### 12.async函数详解及应用

* 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作
* 本质：Generator的语法糖
* 语法

```
async function foo(){
  await 异步操作;
  await 异步操作；
}
```

* 特点：
  1. 返回的总是Promise对象，可以用then方法进行下一步操作
  2. 不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行
  3. async取代Generator函数的星号*，await取代Generator的yield

demo01:

```
async function test01() {
	return new Promise((resolve) => {
		setTimeout(resolve, 2000)
	})
}

async function test02() {
	console.log(new Date().toTimeString())
	await test01()
	console.log(new Date().toTimeString() + '...')
}

test02() // 输出时间字符串， 两秒后输出新时间字符串
```

demo02：async里await的返回值

```
function test03() {
	return "xxx"
}

async function test04() {
	let result = await test03()
	console.log(result) //"xxx"
	result = await Promise.resolve("success")
	console.log(result) //"success"
	result = await Promise.reject("error")
	console.log(result) //报错带"error"
}

test04()
```

demo03：获取新闻评论

```
function myAjax(option) {
  let xhr = new XMLHttpRequest()
  xhr.open(option.method, option.url)
  xhr.onreadystatechange = function() {
    if(xhr.readyState === 4) {
      if(xhr.status === 200 || xhr.status === 304) {
        option.success(xhr.responseText)
      }else{
        option.fail("error")
      }
    }
  }
  xhr.send()
}
async function getNew(url) {
  return new Promise((resolve, reject) => {
    myAjax({
        method: "GET",
        url,
        success: data => resolve(data),
        fail: error => reject(error)
    })
  })
}
async function sendXml() {
  let result = await getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/newId")
  let url = JSON.parse(result).data.obj.url
  let comment = await getNew("https://www.easy-mock.com/mock/5f05d40904736119c8f374d7/ES6demo/" + url)
  console.log(JSON.parse(comment))
}
sendXml()
```

### 13.class类使用详解

* 通过class实现类的继承
  * 通过constructor定义构造方法
  * 通过new来创建类的实例
  * 通过extends来实现类的继承
  * 通过super调用父类的构造方法

```
//传统的构造函数
function Person(name, age) {
	this.name = name
	this.age = age
	
	Person.prototype.showName = function() {
		console.log(this.name)
	}
}
let person = new Person("jack", 12)
console.log(person) // {name: "jack", age: 12}
person.showName() // "jack"
// class定义Person类
class Person {
	constructor(name, age) {
		this.name = name
		this.age = age
	}
	// 必须用对象简写,保存在实例的原型中
	showName() {
		console.log(this.name)
	}
}
let person = new Person("jack", 12)
console.log(person) // {name: "jack", age: 12}
person.showName() // "jack"

// 子类继承父类
class childPerson extends Person{
	constructor(name, age, salary) {
		super(name, age)
		this.salary = salary
	}
	// 类似于java方法的重写,不重写则用父类的原型的方法
	showName() {
		console.log("子类的方法")
		console.log(this.name)
	}
}
let person = new ChildPerson("jack", 13, 100000)
console.log(person)  // {name: "jack", age: 13, salary: 100000}
person.showName // jcak
```

### 14.字符串，数字的扩展

1.字符串的扩展

* includes(str)：判断是否包含指定的字符串，返回布尔值
* startWith(str)：判断是否以指定字符串开头，返回布尔值
* endWith(str)：判断是否以指定字符串结尾，返回布尔值
* repeat(count)：重复指定次数，返回新字符串

```
let str = 'abc'
console.log(str.includes("a")) // true
console.log(str.startsWith("a")) // true
console.log(str.endsWith("c")) // true
console.log(str.repeat(3)) // "abcabcabc"
```

2.数值的扩展

* 二进制与八进制数值表示法：二进制用0b，八进制用0o

```
console.log(0b1010)  // 10
cosnole.log(0o56) // 46
```

* Number.isFinite(i)：判断是否是有限大的数
* Number.isNaN(I)：判断是否是NaN
* Number.isInteger(I)：判断是否是NaN
* Number.parseInt(I)：将字符串转换为对应的数值
* Math.trunc(i)：去除小数部分

```
console.log(Number.isFinite(Infinity)) // false
console.log(Number.isNaN(NaN)) // true
console.log(Number.isInteger(2)) // true
console.log(Number.parseInt("123NaN")) // 123
console.log(Math.trunc(12.234)) // 12
```

### 15.数组方法的扩展

1.Array.from：将伪数组转换为数组

```
function fun () {
	Array.from(arguments).forEach((item) => {
		console.log(item)
	})
}
fun(1, 3, 45)
```

2.Array.of()：将一系列值转换为数组

```
let arr = Array.of("jack", 12)
console.log(arr) ["jack", 12]
```

3.find()：找出第一个满足条件返回true的元素

4.findIndex() ：找出第一个满足条件返回true的元素下标

```
let arr = [1, 3, 5, 7, 4]
let result1 = arr.find((item) => {
 return item > 4 
})
let result2 = arr.findIndex((item) => {
 return item > 4
})
console.log(result1) // 5
console.log(result2) // 2
```

### 16.对象方法的扩展

1.Object.is(v1, v2)：判断两个数据是否完全相等

```
console.log(0 == -0) // true
console.log(NaN == NaN) // false
console.log(Object.is(0, -0)) // false
console.log(Object.is(NaN, NaN)) // true
```

2.Object.assign(target, source1, source2...)：将源对象的属性复制到目标对象上

```
let obj = {}
let obj2 = {name: "jack", age: 12}
let obj3 = {salary: 30000}
Object.assign(obj, obj2, obj3)
console.log(obj) // {name: "jack", age: 12, salary: 30000}
```

3.直接操作\_\_proto\_\_属性

```
let obj = {}
let obj2 = {salary: 30000}
obj.__proto__ = obj2
console.log(obj.salary) // 30000
```

### 17.Set，Map容器

1.Set容器：无序不可重复的多个value的集合体

* Set(array)
* add(value)
* delete(value)
* has(value)
* clear()
* size

```
let setArr = new Set([1, 4, 2, 3, 4, 3, 5])
console.log(setArr) // {1, 4, 2, 3, 5, size: 5}
setArr.add(2) // 不变
setArr.add(7) // {1, 4, 2, 3, 5, 7, size: 6}
setArr.delete(2) // {1, 4, 3, 5, 7, size: 5}
setArr.has(1) // true
setArr.clear() // {size: 0}
```

2.Map容器：无序的key不重复的多个key-value的集合体

* Map(array)
* set(key, value)
* get(key)
* delete(key)
* has(key)
* clear()
* size

```
let setArr = new Map([["name", "jack"],["age", 12]])
console.log(setArr) // {"name" => "jack", "age" => 12, size: 2}
setArr.set("address", "beijin") // {"name" => "jack", "age" => 12, "address" => "beijin", size: 3}
setArr.get("name") // "jack"
setArr.delete("name") // {"age" => 12, "address" => "beijin", size: 2}
setArr.has("address") // true
setArr.clear() // {size: 0}
```

### 18.ES7

1.指数运算符（幂）： **

```
console.log(3 ** 3) // 27
```

2.Array.prototype.includes(value)

```
let arr = [1, 4, "tom"]
console.log(arr.includes("tom")) // true
```
