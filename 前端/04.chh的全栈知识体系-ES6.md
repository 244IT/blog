## ES6

### 01.var、let、const

1.变量提升：var存在变量提升，let、const不存在

```
console.log(name) // undefined
var name = "jack"

console.log(age) //Cannot access 'age' before initialization
let age = 12
```

2.重复定义：var可以重复定义，let、const不可以

3.暂时性死区：let声明会形成暂时性死区

>暂时性死区相当于一个封闭的作用域，不能在这个作用域中声明变量前使用变量，否则会报错

4.块级作用域：var声明的变量没有块级作用域、let、const在块级作用域有效

```
if(true) let a = 5 // 报错
```

5.挂载window：var声明的全局变量会挂载在window上（弊端：全局变量和顶层对象挂钩），而let和const不会

6.修改值：var、let声明的变量值可修改，const不可修改，用来声明常量

>那么如何使对象不可变？使用递归Object.freeze()

7.先声明后赋值：var、let可以先声明变量，后赋值，const不行

### 02.变量的结构赋值

1.理解：

* 从对象或数组中提取数据, 并赋值给变量(多个)

2.对象的解构赋值：

* 以前我们获取对象属性值的方式

```
let obj = {name : 'kobe', age : 39};
let name = obj.name;
let age = obj.age;
console.log(name, age);

function person(p) {//不用解构赋值
	console.log(p.name, p.age);
}
person(obj);
```

* 使用对象解构赋值

```
let {name, age} = {name : 'kobe', age : 39};
console.log(name, age);

function person1({name, age}) {
	console.log(name, age);
}
person1(obj);
```

3.数组的解构赋值

```
let arr = ['abc', 23, true];
let [a, b, c, d] = arr;
console.log(a, b, c, d); // 'abc', 23, true, undefined
```

解构的默认值是惰性的

```
let [a = foo()] = [1] // 不会打印123

function foo() {
	console.log(123)
}
```

* 因为a本身是可以取到值的，所以不会执行=右边

### 03.字符串的扩展

#### 4.1.Unicode表示

ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。

```js
"\u0061"
// "a"
```

但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

```js
"\uD842\uDFB7"
// "𠮷"

"\u20BB7"
// " 7"
```

上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

```js
"\u{20BB7}"
// "𠮷"
```

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

```js
'\z' === 'z' // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

#### 4.2.遍历器接口

ES6 为字符串添加了遍历器接口，详见Iterator一节，使得字符串可以被for...of循环遍历。

```js
for (let item of 'imooc') {
    console.log(item)
}
```

#### 4.3.模板字符串

在 ES6 之前对字符串的处理是相当的麻烦，看如下场景：

**1. 字符串很长要换行**

字符串很长包括几种情形一个是开发时输入的文本内容，一个是接口数据返回的文本内容。如果对换行符处理不当，就会带来异常。

**2. 字符串中有变量或者表达式**

如果字符串不是静态内容，往往是需要加载变量或者表达式，这个也是很常见的需求。之前的做法是字符串拼接：

```js
  var a = 20
  var b = 10
  var c = 'JavaScript'
  var str = 'My age is ' + (a + b) + ' and I love ' + c
  console.log(str)
```

如果字符串有大量的变量和表达式，这个拼接简直是噩梦。

**3. 字符串中有逻辑运算**

我们通常写代码都是有逻辑运算的，对于字符串也是一样，它包含的内容不是静态的，通常是根据一定的规则在动态变化。

```js
  var retailPrice = 20
  var wholesalePrice = 16
  var type = 'retail'

  var showTxt = ''

  if (type === 'retail') {
      showTxt += '您此次的购买单价是：' + retailPrice
  } else {
      showTxt += '您此次的批发价是：' + wholesalePrice
  }
```

看到这样的代码一定会感到很熟悉，通常大家的做法是使用上述的字符串拼接+逻辑判断，或者采用字符串模板类库来操作。

**String Literals**

看了上述的应用场景，就要引入 String Literals 话题，这个是用来解决字符串拼接问题，从 ES6 开始可以这样定义字符串了。

```js
`string text` 

`string text line 1
 string text line 2`

`string text ${expression} string text` 
```

在这里你可以任意插入变量或者表达式，只要用 ```${}` ``包起来就好。

注意

这里的符号是反引号，也就是数字键 1 左边的键，不是单引号或者双引号

这样就可以轻松解决字符串包含变量或者表达式的问题了，对于多行的字符串，之前是这样处理

```js
console.log('string text line 1\n' +
    'string text line 2')
// "string text line 1
// string text line 2"
```

现在可以这样做了

```js
console.log(`string text line 1
string text line 2`)
// "string text line 1
// string text line 2"
```

完全不需要 ```\n` ``来参与。

**Tag Literals**

前面的字符串字面量解决了字符串拼接的问题，对于包含复杂逻辑的字符串并不是简单的表达式能搞定的。所以需要另一种解决方案：Tag Literals，还是看上述那个例子:

```js
var retailPrice = 20
var wholesalePrice = 16
var type = 'retail'

var showTxt = ''

if (type === 'retail') {
    showTxt += '您此次的购买单价是：' + retailPrice
} else {
    showTxt += '您此次的批发价是：' + wholesalePrice
}
```

现在可以定义一个 Tag 函数，然后用这个 Tag 函数来充当一个模板引擎：

```js
function Price(strings, type) {
    let s1 = strings[0]
    const retailPrice = 20
    const wholesalePrice = 16
    let txt = ''
    if (type === 'retail') {
        txt = `购买单价是：${retailPrice}` 
    } else {
        txt = `批发价是：${wholesalePrice}` 
    }
    return `${s1}${txt}` 
}

let showTxt = Price `您此次的${'retail'}` 

console.log(showTxt) //您此次的购买单价是：20
```

TIP

strings 参数指的是 Tag 函数后面被变量分割开的字符串集合，type 参数是对应第一个变量，Tag 函数可以有多个 type 类似的参数

#### 4.4.新增方法

**String.prototype.fromCodePoint()**

用于从 Unicode 码点返回对应字符，并且可以识别大于0xFFFF的字符。

```js
// ES5
console.log(String.fromCharCode(0x20BB7))

// ES6
console.log(String.fromCodePoint(0x20BB7))
```

**String.prototype.includes()**

ES5中可以使用indexOf方法来判断一个字符串是否包含在另一个字符串中，indexOf返回出现的下标位置，如果不存在则返回-1。

```js
const str = 'imooc'

console.log(str.indexOf('mo'))
```

ES6提供了includes方法来判断一个字符串是否包含在另一个字符串中，返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.includes('mo'))
```

**String.prototype.startsWith()**

判断参数字符串是否在原字符串的头部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.startsWith('im'))
```

**String.prototype.endsWith()**

判断参数字符串是否在原字符串的尾部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.endsWith('mooc'))
```

**String.prototype.repeat()**

repeat方法返回一个新字符串，表示将原字符串重复n次。

```js
const str = 'imooc'

const newStr = str.repeat(10)

console.log(newStr)
```

* 如果参数传入0或者负数的话，返回值为unde

### 04.数字的扩展

#### 4.1.二进制与八进制

请大家思考在JS中如何把十进制转化为二进制？

```js
const a = 5 // 101

console.log(a.toString(2))
```

如何把八进制转化为二进制？

```js
const b = 101

console.log(parseInt(b, 2))
```

ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。

```js
const a = 0B0101
console.log(a)

const b = 0O777
console.log(b)
```

#### 4.2.Number新增方法

**Number.isFinite()**

用来检查一个数值是否为有限的（finite），即不是Infinity。

```js
Number.isFinite(15) // true
Number.isFinite(0.8) // true
Number.isFinite(NaN) // false
Number.isFinite(Infinity) // false
Number.isFinite(-Infinity) // false
Number.isFinite('foo') // false
Number.isFinite('15') // false
Number.isFinite(true) // false
```

**Number.isNaN()**

用来检查一个值是否为NaN。

```js
Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN('15') // false
Number.isNaN(true) // false
Number.isNaN(9 / NaN) // true
Number.isNaN('true' / 0) // true
Number.isNaN('true' / 'true') // true
```

**Number.parseInt()**

ES6 将全局方法parseInt()移植到Number对象上面，行为完全保持不变。 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```js
// ES5的写法
parseInt('12.34') // 12

// ES6的写法
Number.parseInt('12.34') // 12
```

**Number.parseFloat()**

ES6 将全局方法parseFloat()移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```js
// ES5的写法
parseFloat('123.45#') // 123.45

// ES6的写法
Number.parseFloat('123.45#') // 123.45
```

**Number.isInteger()**

用来判断一个数值是否为整数。

```js
Number.isInteger(25) // true
Number.isInteger(25.1) // false

Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```

**Number.MAX_SAFE_INTEGER**

```js
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true

Number.MAX_SAFE_INTEGER === 9007199254740991 // true
```

**Number.MIN_SAFE_INTEGER**

```js
Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true

Number.MIN_SAFE_INTEGER === -9007199254740991 // true
```

**Number.isSafeInteger()**

JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。

```js
Math.pow(2, 53) // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
```

#### 4.3.Math新增方法

**Math.trunc()**

方法用于去除一个数的小数部分，返回整数部分。

```js
console.log(Math.trunc(5.5))
console.log(Math.trunc(-5.5))
console.log(Math.trunc(true)) // 1
console.log(Math.trunc(false)) // 0
console.log(Math.trunc(NaN)) // NaN
console.log(Math.trunc(undefined)) // NaN
console.log(Math.trunc()) // NaN
```

**Math.sign()**

方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

它会返回五种值。

- 参数为正数，返回+1
- 参数为负数，返回-1
- 参数为 0，返回0
- 参数为-0，返回-0
- 其他值，返回NaN

```js
console.log(Math.sign(5)) // 1
console.log(Math.sign(-5)) // -1
console.log(Math.sign(0)) // 0
console.log(Math.sign(NaN)) // NaN
console.log(Math.sign(true)) // 1
console.log(Math.sign(false)) // 0
```

**Math.cbrt()**

方法用于计算一个数的立方根。

```js
console.log(Math.cbrt(8)) // 2

console.log(Math.cbrt('imooc')) // NaN
```

### 05.数组的扩展

#### 15.1.ES5中的数组遍历方式

```js
let arr = [1, 2, 3, 2, 4]
```

**for循环**

```js
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i])
}
```

后来语法有所升级，到 ES5 遍历数组的 API 多了起来，其中有 forEach、every、filter等，同样的功能可以用 forEach 、 map 、 every 等方法来实现。

**forEach() 没有返回值，只是针对每个元素调用func**

```js
arr.forEach(function(elem, index, array) {
    if (arr[i] == 2) {
        continue
    }
    console.log(elem, index)
})
```

这个语法看起来要简洁很多，不需要通过索引去访问数组项，然而它的缺点也是很明显，不支持 break、continue 等。

```js
[1, 2, 3, 4, 5].forEach(function(i) {
    if (i === 2) {
        return;
    } else {
        console.log(i)
    }
})
```

这段代码的"本意"是从第一个元素开始遍历，遇到数组项 2 之后就结束遍历，不然打印出所遍历过的数值项。可是，事实让你大跌眼镜，因为它的输出是 1, 3, 4, 5。

注意

forEach 的代码块中不能使用 break、continue，它会抛出异常。

**map() 返回新的数组，每个元素为调用func的结果**

```js
let result = arr.map(function(value) {
    value += 1
    console.log(value)
    return value
})
console.log(arr, result)
```

**filter() 返回符合func条件的元素数组**

```js
let result = arr.filter(function(value) {
    console.log(value)
    return value == 2
})
console.log(arr, result)
```

**some() 返回boolean，判断是否有元素符合func条件**

```js
let result = arr.some(function(value) {
    console.log(value)
    return value == 4
})
console.log(arr, result)
```

**every() 返回boolean，判断每个元素都符合func条件**

```js
let result = arr.every(function(value) {
    console.log(value)
    return value == 2
})
console.log(arr, result)
```

同样完成刚才的目标，使用 every 遍历就可以做到 break 那样的效果，简单的说 return false 等同于 break，return true 等同于 continue。如果不写，默认是 return false。

注意

every 的代码块中不能使用 break、continue，它会抛出异常。

**reduce() 接收一个函数作为累加器**

```js
let sum = arr.reduce(function(prev, cur, index, array) {
    return prev + cur
}, 0)
console.log(sum)
let max = arr.reduce(function(prev, cur) {
    return Math.max(prev, cur)
})
console.log(max)
let res = arr.reduce(function(prev, cur) {
    prev.indexOf(cur) == -1 && prev.push(cur)
    return prev
}, [])
console.log(res)
```

有的同学会说，还有 for...in 可以遍历数组。

```js
for (var index in array) {
    console.log(array[index]);
}
```

说的没错，for...in 确实可以遍历数组，而且还支持 continue、break等功能，但是它真的没有瑕疵吗？如果 array 有自定义属性，你发现也会被遍历出来(显然不合理)。这是因为 for...in 是为遍历对象创造的（{a:1, b:2}），不是为数组设计的。

>注意
>
>for...in不能用于遍历数组。
>for...in代码块中不能有 return，不然会抛出异常。

#### 15.2.ES6中的数组遍历方式

**Array.prototype.find()**

find() 找出第一个满足条件返回true的元素，否则返回 undefined。

```js
let array = [5, 12, 8, 130, 44];

let found = array.find(function(element) {
    return element > 10;
});

console.log(found);
// 12
```

**语法：**`arr.find(callback[, thisArg])`

|   参数   |                             含义                             | 必选 |
| :------: | :----------------------------------------------------------: | :--: |
| callback | 在数组每一项上执行的函数，接收 3 个参数，element、index、array |  Y   |
| thisArg  |                  执行回调时用作 this 的对象                  |  N   |

**Array.prototype.findIndex()**

findIndex()方法找出第一个满足条件返回true的元素下标。否则返回-1。其实这个和 find() 是成对的，不同的是它返回的是索引而不是值。

```js
let array = [5, 12, 8, 130, 44];

let found = array.find(function(element) {
    return element > 10;
});

console.log(found);
// 1
```

**语法：**`arr.findIndex(callback[, thisArg])`

|   参数   |                             含义                             | 必选 |
| :------: | :----------------------------------------------------------: | :--: |
| callback | 在数组每一项上执行的函数，接收 3 个参数，element、index、array |  Y   |
| thisArg  |                  执行回调时用作 this 的对象                  |  N   |

**for...of**

```js
for (let val of [1, 2, 3]) {
    console.log(val);
}
// 1,2,3
```

上述代码中轻松实现了数组的遍历，乍一看没有绝对它有非常强大之处。我们不得不强调下，for...of 的来历和作用。

```js
for (variable of iterable) {

}
```

看下这个伪代码，of 后面是 iterable 既不是 for 循环规定的 array，也不是 for...in 规定的 Object，而是 iterable。如果查查 iterable 的含义就很直观的感受到 for...of 遍历的是一切可遍历的元素（数组、对象、集合）等，不要小瞧这个功能，因为在 ES6 中允许开发者自定义遍历，换句话说任何数据结构都可以自定义一个遍历，这个遍历是不能被 for、for...in 理解和实现的。很抽象吧？Iterator 是如何实现的这是ES6的新增语法，后面课程中 `Iterator` 一节会讲。

```js
for (let item of arr) {
    console.log(item)
}

for (let item of arr.values()) {
    console.log(item)
}

for (let item of arr.keys()) {
    console.log(item)
}

for (let [index, item] of arr.entries()) {
    console.log(index, item)
}
```

TIP

for...of是支持 break、continue、return的，所以在功能上非常贴近原生的 for。

**values()**

```
const arr = [0, 1, 2, 4]

for(let index of arr.keys()) { 
  console.log(index) // 0, 1, 2, 4
}
```

**keys()**

```
const arr = [0, 1, 2, 4]

for(let index of arr.keys()) { 
  console.log(index) // 0, 1, 2, 3
}
```

**entries()**

```
const arr = [0, 1, 2, 4]

for(let [index, item] of arr.entries()) {
  console.log(item + '--' + index)
}
```

#### 15.3.数组方法的扩展

**1.Array.from：将伪数组转换为数组**

* 伪数组：选择器（querySelectAll，getElementByNames，getElementByClassNames...），arguments属性

ES5

```
let args = [].slice.call(arguments);
let imgs = [].slice.call(document.querySelectorAll('img'));
```

ES6

```
function fun () {
	Array.from(arguments).forEach((item) => {
		console.log(item)
	})
}
fun(1, 3, 45)
```

**惊喜**

难道 Array.from 只能用来将伪数组转换成数组吗，还有其他用法吗？这要来看下 Array.from 的几个参数：

**语法：**`Array.from(arrayLike[, mapFn[, thisArg]])`

|   参数    |                         含义                         | 必选 |
| :-------: | :--------------------------------------------------: | :--: |
| arrayLike |        想要转换成数组的伪数组对象或可迭代对象        |  Y   |
|   mapFn   | 如果指定了该参数，新数组中的每个元素会执行该回调函数 |  N   |
|  thisArg  |      可选参数，执行回调函数 mapFn 时 this 对象       |  N   |

看了这几个参数至少能看到 Array.from 还具备 map 的功能，比如我们想初始化一个长度为 5 的数组，每个数组元素默认为 1，之前的做法是这样的：

```js
let arr = Array(6).join(' ').split('').map(item => 1)
// [1,1,1,1,1]
```

这样写虽然也能实现，但是用起来比较繁琐，使用 Array.from 就会简洁很多。

```js
Array.from({
    length: 5
}, function() {
    return 1
})
```

这个代码看起来既简洁还容易理解

**2.Array.of()：将一系列值转换为数组**

```
let arr = Array.of("jack", 12)
console.log(arr) ["jack", 12]
```

* 相比于new Array（）的方式创建数组，在只有一个数字的时候，new Array代表的是长度，而Array.of代表的是数组值。

```
new Array(3) // [ , , ]
Array.of(3) // [3]
```

**3.Array.prototype.fill()**

fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

```js
let array = [1, 2, 3, 4]
array.fill(0, 1, 2)
// [1,0,3,4]
```

这个操作是将 array 数组的第二个元素（索引为1）到第三个元素（索引为2）内的数填充为 0，不包括第三个元素，所以结果是 [1, 0, 3, 4]

我们前面有提到用 Array.from 初始化为一个长度固定，元素为指定值的数组。如果用 fill 是否可以达到同样的效果呢？

```js
Array(5).fill(1)
// [1,1,1,1,1]
```

**4.Array.prototype.copyWithin()**

在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

**语法：**`arr.copyWithin(target, start = 0, end = this.length)`

|  参数  |                             含义                             | 必选 |
| :----: | :----------------------------------------------------------: | :--: |
| target |          从该位置开始替换数据。如果为负值，表示倒数          |  Y   |
| start  | 从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算 |  N   |
|  end   | 到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算 |  N   |

```js
let arr = [1, 2, 3, 4, 5]
console.log(arr.copyWithin(1, 3))
// [1, 4, 5, 4, 5]
```

**5.Array.prototype.includes()**

在 ES7 之前想判断数组中是否包含一个元素，基本可以这样写：

```js
console.log(array1.find(function(item) {
    return item === 2
}))
```

或者

```js
console.log(array1.filter(function(item) {
    return item === 2
}).length > 0)
```

ES7引入的Array.prototype.includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

**基本用法**

```js
const arr = ['es6', 'es7', 'es8']
console.log(arr.includes('es6')) // true
console.log(arr.includes('es9')) // false
```

**接收俩个参数**

要搜索的值和搜索的开始索引。第二个参数可选。从该索引处开始查找 searchElement。如果为负值，

```js
const arr = ['es6', 'es7', 'es8']
console.log(arr.includes('es7', 1)) // true
console.log(arr.includes('es7', 2)) // false
console.log(arr.includes('es7', -1)) // false
console.log(arr.includes('es7', -2)) // true
```

**与indexOf()比较**

```js
['a', 'b', 'c'].includes('a') //true
['a', 'b', 'c'].indexOf('a') > -1 //true

console.log(arr.indexOf('es7')) // 1
console.log(arr.indexOf('es7') > -1) // true
```

注意

只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些是无法判断的.

```js
const arr = [1, [2, 3], 4]
arr.includes([2, 3]) //false
arr.indexOf([2, 3]) //-1
```

**优缺点比较**

两者都是采用===的操作符来作比较的，不同之处在于：对于NaN的处理结果不同。我们知道js中 NaN === NaN 的结果是false, indexOf()也是这样处理的，但是includes()不是这样的。

```js
const demo = [1, NaN, 2, 3]
demo.indexOf(NaN) //-1
demo.includes(NaN) //true
```

总结

如果只想知道某个值是否在数组中存在，而并不关心它的索引位置，建议使用includes()。如果想获取一个值在数组中的位置，那么只能使用indexOf方法。

### 06.正则的扩展

#### 6.1.y修饰符

ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

```js
const s = 'aaa_aa_a'
const r1 = /a+/g
const r2 = /a+/y

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。

如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。

```js
const s = 'aaa_aa_a'
const r = /a+_/y

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
```

上面代码每次匹配，都是从剩余字符串的头部开始。

使用lastIndex属性，可以更好地说明y修饰符。

```js
const regexp = /a/g

// 指定从2号位置（y）开始匹配
regexp.lastIndex = 2

// 匹配成功
const match = regexp.exec('xaya')

// 在3号位置匹配成功
console.log(match.index) // 3

// 下一次匹配从4号位开始
console.log(regexp.lastIndex) // 4

// 4号位开始匹配失败
regexp.exec('xaxa') // null
```

上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。

```js
const regexp = /a/y

// 指定从2号位置开始匹配
regexp.lastIndex = 2

// 不是粘连，匹配失败
regexp.exec('xaya') // null

// 指定从3号位置开始匹配
regexp.lastIndex = 3

// 3号位置是粘连，匹配成功
const match = regexp.exec('xaxa')
console.log(match.index) // 3
console.log(regexp.lastIndex) // 4
```

进一步说，y修饰符号隐含了头部匹配的标志^。

```js
const reg = /b/y
reg.exec('aba')
// null
console.log(reg.lastIndex)
```

TIP

sticky 模式在正则匹配过程中只会影响两件事：

- 匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）
- 如果匹配到会修改 re.lastIndex（相当于 g 模式）

#### 6.2.u修饰符

ES6为正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于 `\uFFFF` 的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。

```js
/^\uD83D/u.test('\uD83D\uDC2A') // false

    /
    ^ \uD83D / .test('\uD83D\uDC2A') // true
```

上面代码中， `\uD83D\uDC2A` 是一个四个字节的UTF-16编码，代表一个字符 "🐪"。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。

一旦加上u修饰符号，就会修改下面这些正则表达式的行为。

**(1) 点字符**

点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上u修饰符。

```js
let s = '𠮷'

    /
    ^ .$ / .test(s) // false

    /
    ^ .$ / u.test(s) // true
```

上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

TIP

'𠮷'这个字读 jí，是'吉'字的异形体，Unicode 码点 [U+20BB7](https://www.fileformat.info/info/unicode/char/20bb7/index.htm)

**(2) Unicode字符表示法**

ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。

```js
/\u{61}/.test('a') // false

    /
    \u {
        61
    }
/u.test('a') / / true

    /
    \u {
        20 BB7
    }
/u.test('𠮷') / / true
```

上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。

**(3) 量词**

使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。

```js
/a{2}/.test('aa') // true

    /
    a {
        2
    }
/u.test('aa') / / true

    /
    𠮷{
        2
    }
/.test('𠮷𠮷') / / false

    /
    𠮷{
        2
    }
/u.test('𠮷𠮷') / / true
```

另外，只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。

```js
/^\u{3}$/.test('uuu') // true
```

上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。

```js
/\u{20BB7}{2}/u.test('𠮷𠮷') // true
```

使用 u 修饰符之后 Unicode 表达式+量词也是可以的。

**(4) 预定义模式**

u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。

```js
/^\S$/.test('𠮷') // false

    /
    ^ \S$ / u.test('𠮷') // true
```

上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。

利用这一点，可以写出一个正确返回字符串长度的函数。

```js
function codePointLength(text) {
    const result = text.match(/[\s\S]/gu)
    return result ? result.length : 0
}

const s = '𠮷𠮷'

s.length // 4
codePointLength(s) // 2
```

**(5) i修饰符**

有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。

```js
/[a-z]/i.test('\u212A') // false

    /
    [a - z] / iu.test('\u212A') // true
```

上面代码中，不加u修饰符，就无法识别非规范的K字符

### 07.对象的扩展

#### 7.1.对象属性、方法简写

```
let x = 3;
let y = 5;
//普通额写法
let obj = {
    x : x,
    y : y,
    getPoint : function () {
    	return this.x + this.y
    }
};

//简化的写法
let obj = {
    x,
    y,
    getPoint () {
    	return this.x
    }
};
console.log(obj, obj.getPoint());
```

* 对象中的方法不适合使用箭头函数

#### 7.2.属性计算值

```
let s = 'school'
const obj = {
	[s] : '清华大学'
}
```

#### 7.3.Object.is(v1, v2)

判断两个数据是否完全相等

```
console.log(0 == -0) // true
console.log(NaN == NaN) // false
console.log(Object.is(0, -0)) // false
console.log(Object.is(NaN, NaN)) // true
```

* 跟全等号‘===’的区别是NaN和0的判断

#### 7.4.Object.assign(target, source1, source2...)

将源对象的属性复制到目标对象上

```
let obj = {}
let obj2 = {name: "jack", age: 12}
let obj3 = {salary: 30000}
Object.assign(obj, obj2, obj3)
console.log(obj) // {name: "jack", age: 12, salary: 30000}
```

#### 7.5.对象遍历

1.for...in（ES5）

```
const obj = {
	name: 'chh',
	age: 18,
	school: '清华'
}
for(let key in obj) {
	console.log(key, obj[key])
}
```

2.Object.keys()

```
Object.keys(obj).forEach(key => {
	console.log(key, obj[key])
})
```

3.Object.getOwnPropertyNames

```
Object.getOwnPropertyNames(obj).forEach(key => {
	console.log(key, obj[key])
})
```

4.Reflect.ownKeys()

```
Reflect.ownKeys(obj).forEach(key => {
	console.log(key, obj[key])
})
```

#### 7.6.拓展运算符

```
const obj = {
	name: 'chh',
	age: 18,
	school: '清华'
}

const obj2 = {
	emale: '10010',
	...obj
}
console.log(obj2)
```

#### 7.7.in

```
const obj = {
	name: 'chh',
	age: 18,
	school: '清华'
}
console.log(name in obj)

let arr = ['chh', 'yxc', 'rose']
console.log(1 in arr)  //true
```

* 数组中的in表示该索引位置是否有值

#### 7.8.深拷贝和浅拷贝

* 浅拷贝：会复制引用的拷贝方法称为浅拷贝
* 深拷贝：指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个

**浅拷贝**：   

1.数组

* slice
* concat

```
var arr = ['old', 1, true, null, undefined];

var new_arr = arr.concat();

new_arr[0] = 'new';

console.log(arr) // ["old", 1, true, null, undefined]
console.log(new_arr) // ["new", 1, true, null, undefined]

var new_arr = arr.slice();
```

2.对象

* Object.assign

深拷贝**：

* JSON.parse( JSON.stringify() )

>缺点：1.不能拷贝函数

**浅拷贝实现**

```
var shallowCopy = function(obj) {
    // 只拷贝对象
    if (typeof obj !== 'object') return;
    // 根据obj的类型判断是新建一个数组还是对象
    var newObj = obj instanceof Array ? [] : {};
    // 遍历obj，并且判断是obj的属性才拷贝
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
```

**深拷贝实现**

```
var deepCopy = function(obj) {
    if (typeof obj !== 'object') return;
    var newObj = obj instanceof Array ? [] : {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
        }
    }
    return newObj;
}
```

#### 7.9.面向对象和面向过程

面向过程：当我们要完成一个需求的时候，我们关心的是要把这个需求分为几个步骤，当这几个步骤实现了，这个需求就完成了

面向对象：我们会分析这个需求可以分为几个对象，这个对象具有哪些属性和方法

举个例子：

把一个大象装进冰箱

* 面向对象：1:打开冰箱，2:把冰箱装进冰箱，3:关闭冰箱
* 面向过程：1.分析需求有大象和冰箱两个对象，2.大象应该有体积的属性，装进冰箱的行为。冰箱应该有容量的属性，打开关闭的行为。3.基于这些属性判断大象是否达到条件，如果可以则打开装进冰箱，然后关闭。

### 08.箭头函数

1.基本语法

* 没有参数: () => console.log('xxxx')

* 一个参数: i => i+2

* 大于一个参数: (i,j) => i+j

* 函数体不用大括号: 默认返回结果

* 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回

```
let fun = function () {
	console.log('fun()');
};
fun();
//没有形参，并且函数体只有一条语句
let fun1 = () => console.log('fun1()');
fun1();
console.log(fun1());
//一个形参，并且函数体只有一条语句
let fun2 = x => x;
console.log(fun2(5));
//形参是一个以上
let fun3 = (x, y) => x + y;
console.log(fun3(25, 39));//64

//函数体有多条语句
let fun4 = (x, y) => {
	console.log(x, y);
	return x + y;
};
console.log(fun4(34, 48));//82
```

2.箭头函数和普通函数的区别：

* 简洁
* 箭头函数的this不是调用的时候决定的，箭头函数没有自己的this，而是会沿着作用域链向外层作用域查找，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。

```
let btn = document.getElementById('btn');
//没有箭头函数
btn.onclick = function () {
	console.log(this);//btn
};
//箭头函数
let btn2 = document.getElementById('btn2');

btn2.onclick = function () {
	console.log(this);//btn
};

let obj = {
    name : 'kobe',
    age : 39,
    getName : () => {
    	btn2.onclick = () => {
    		console.log(this);//window
    	};
    }
};
obj.getName();

function Person() {
    this.obj = {
        showThis : () => {
        	console.log(this);
        }
    }
}
let fun5 = new Person();
fun5.obj.showThis();
```

* 不能作为构造函数

```
const People = (name, age) => {
  this.name = name
  this.age = age
}

const people = new People('chh', 18)
//Uncaught TypeError: People is not a constructor
```

* 不可以使用argument对象

```
const fun = (name, age) => {
  console.log(arguments)
}

fun('chh', 12)
// index.html:18 Uncaught ReferenceError: arguments is not defined
```

### 09.扩展运算符和rest参数

1.rest(可变)参数：把逗号隔开的值组成一个数组（等号左边，形参）

* 用来取代arguments 但比arguments灵活,只能是最后部分形参参数

```
function fun(...values) {
	console.log(arguments);
//  arguments.forEach(function (item, index) {
//       console.log(item, index);
//  });
	
	Array.prototype.forEach.call(argument, (item, index) => {
		console.log(item, index)
	})
	
	console.log(values);
    values.forEach(function (item, index) {
    	console.log(item, index);
    })
}
fun(1,2,3);

const [x, ...arg] = [0, 1, 2]
```

2.扩展运算符：把数组或者类数组展开成用逗号隔开的值（等号右边，实参）

```
let arr1 = [1, 3, 5];
let arr2 = [2, ...arr1, 6];
arr2.push(...arr1);
```

### 10.函数的参数

#### 7.1.形参默认值

* 当不传入参数的时候默认使用形参里的默认值

ES5

```
//定义一个点的坐标
function Point(x, y) {
    this.x = x || 12;
    this.y = y || 12;
}
或
function Point(x, y) {
    this.x = x ? x : 12;
    this.y = y ? y : 12;
}
```

* 如果x和y为0的话，最终会被赋值12

ES6

```
//定义一个点的坐标
function Point(x = 12, y = 12) {
    this.x = x;
    this.y = y;
}
let point = new Point(25, 36);
console.log(point);
let p = new Point();
console.log(p);
```

* 参数的默认值最好放在最后面

#### 7.2.与解构赋值结合

```
function ajax(url, {
    body = '',
    method = 'GET',
    headers = {}
} = {}) {
    console.log(method)
}

ajax('http://www.imooc.com', {
    method: 'POST'
})
```

#### 7.3.length属性

函数指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。

```js
function foo(x = 1, y = 2, z = 3) {
    console.log(x, y)
}
console.log(foo.length)
// 0
```

#### 7.4.作用域

```
let x = 2
function foo1(x = 1, y = x) {
	console.log(y) // 1
}

function foo2(y = x) {
	console.log(y) // 2
}

function foo3(z = y) {
	console.log(z) // 报错
}
```

#### 7.5.函数的name属性

函数的name属性，返回该函数的函数名。

```js
function foo() {}

foo.name // "foo"
```

### 11.symbol属性

#### 10.1.理解：

* ES6 引入了一种新的原始（基本）数据类型 `Symbol` ，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

  Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

#### 10.2.特点：

* Symbol属性对应的值是唯一的，解决命名冲突问题

* Symbol值不能与其他数据进行计算，包括同字符串拼串

* for in, for of遍历时不会遍历symbol属性。

#### 10.3.声明方式：

```js
let s = Symbol()

typeof s
// "symbol"
```

变量s就是一个独一无二的值。typeof的结果说明s是 Symbol 数据类型。

既然是独一无二的，那么两个Symbol()就一定是不相等的：

```js
let s1 = Symbol()
let s2 = Symbol()
console.log(s1)
console.log(s2)
console.log(s1 === s2) // false
```

>Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

```js
let s1 = Symbol('foo')
let s2 = Symbol('foo')
console.log(s1)
console.log(s2)
console.log(s1 === s2) // false
```

**Symbol.for()**

`Symbol.for()` 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。

```js
let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')
console.log(s1 === s2) // true
```

注意

Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。

**Symbol.keyFor()**

Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。

```js
const s1 = Symbol('foo')
console.log(Symbol.keyFor(s1)) // undefined

const s2 = Symbol.for('foo')
console.log(Symbol.keyFor(s2)) // foo
```

#### 10.4.Symbol的应用场景

**作为属性名**

由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

比如在一个班级中，可能会有同学名字相同的情况，这时候使用对象来描述学生信息的时候，如果直接使用学生姓名作为key会有有问题。

```js
const grade = {
    张三: {
        address: 'xxx',
        tel: '111'
    },
    李四: {
        address: 'yyy',
        tel: '222'
    },
    李四: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
// 只会保留最后一个李四
```

如果使用Symbol，同名的学生信息就不会被覆盖：

```js
const stu1 = Symbol('李四')
const stu2 = Symbol('李四')
const grade = {
    [stu1]: {
        address: 'yyy',
        tel: '222'
    },
    [stu2]: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
console.log(grade[stu1])
console.log(grade[stu2])
```

**属性遍历**

```js
const sym = Symbol('imooc')
class User {
    constructor(name) {
        this.name = name
        this[sym] = 'imooc.com'
    }
    getName() {
        return this.name + this[sym]
    }
}
const user = new User('xiecheng')
console.log(user.getName())

for (let key in user) {
    console.log(key)
}

for (let key of Object.keys(user)) {
    console.log(key)
}

for (let key of Object.getOwnPropertySymbols(user)) {
    console.log(key)
}

for (let key of Reflect.ownKeys(user)) {
    console.log(key)
}
```

* Reflect.ownKeys可以遍历普通属性及symbol属性

**消除魔术字符串**

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```js
function getArea(shape) {
    let area = 0
    switch (shape) {
        case 'Triangle':
            area = 1
            break
        case 'Circle':
            area = 2
            break
    }
    return area
}
console.log(getArea('Triangle'))
```

上面代码中，字符串Triangle和Circle就是魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。

使用Symbol就可以很好的解决这个问题：

```js
const shapeType = {
    triangle: Symbol(),
    circle: Symbol()
}

function getArea(shape) {
    let area = 0
    switch (shape) {
        case shapeType.triangle:
            area = 1
            break
        case shapeType.circle:
            area = 2
            break
    }
    return area
}
console.log(getArea(shapeType.triangle))
```

#### 10.5.内置Symbol值

* 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。

​     \- Symbol.iterator

* 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)

### 12.Proxy

在 ES6 标准中新增的一个非常强大的功能是 Proxy，它可以自定义一些常用行为如查找、赋值、枚举、函数调用等。通过 Proxy 这个名称也可以看出来它包含了“代理”的含义，只要有“代理”的诉求都可以考虑使用 Proxy 来实现。

#### 12.1.基本语法

**语法**

```js
let p = new Proxy(target, handler)
```

**解释**

|  参数   |                             含义                             | 必选 |
| :-----: | :----------------------------------------------------------: | :--: |
| target  | 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） |  Y   |
| handler |    一个对象，其属性是当执行一个操作时定义代理的行为的函数    |  Y   |

MDN 给出的解释偏官方，通俗的讲第一个参数 target 就是用来代理的“对象”，被代理之后它是不能直接被访问的，而 handler 就是实现代理的过程。

#### 12.2.拦截操作场景

**场景**

我们经常读取一个对象的 key-value：

```js
let o = {
    name: 'xiaoming',
    age: 20
}

console.log(o.name) // xiaoming
console.log(o.age) // 20
console.log(o.from) // undefined
```

当我们读取 from 的时候返回的是 undefined，因为 o 这个对象中没有这个 key-value。想想看我们在读取数据的时候，这个数据经常是聚合的，当大家没有按照规范来的时候或者数据缺失的情况下，经常会出现这种“乌龙”现象。

如果我们不想在调用 key 的时候返回 undefined，之前的做法是这样的：

```js
console.log(o.from || '')
```

如果我们对所有代码都是这种写法，那阅读性和观赏性就不得而知了。值得庆幸的是，ES6 的 Proxy 可以让我们轻松的解决这一问题：

```js
let o = {
    name: 'xiaoming',
    age: 20
}

let handler = {
    get(obj, key) {
        return Reflect.has(obj, key) ? obj[key] : ''
    }
}

let p = new Proxy(o, handler)

console.log(p.from)
```

这个代码是想表达如果 o 对象有这个 key-value 则直接返回，如果没有一律返回 `''` ，当然这里是自定义，大家可以根据自己的需要来写适合自己业务的规则。

刚才对数据的“读操作”进行了拦截，接下来我们描述下“写操作”进行拦截。

**场景 1**

从服务端获取的数据希望是只读，不允许在任何一个环节被修改。

```js
// response.data 是 JSON 格式的数据，来自服务端的响应
// 在 ES5 中只能通过遍历把所有的属性设置为只读
for (let [key] of Object.entries(response.data)) {
    Object.defineProperty(response.data, key, {
        writable: false
    })
}
```

如果我们使用 Proxy 就简单很多了：

```js
let data = new Proxy(response.data, {
    set(obj, key, value) {
        return false
    }
})
```

**场景 2**

对于数据交互而言，校验是不可或缺的一个环境，传统的做法是将校验写在了业务逻辑里，导致代码耦合度较高。如果大家使用 Proxy 就可以将代码设计的非常灵活。

```js
// Validator.js
export default (obj, key, value) => {
    if (Reflect.has(key) && value > 20) {
        obj[key] = value
    }
}

import Validator from './Validator'
let data = new Proxy(response.data, {
    set: Validator
})
```

**场景 3**

如果对读写进行监控，可以这样写：

```js
let validator = {
    set(target, key, value) {
        if (key === 'age') {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                throw new TypeError('Age must be a number')
            }
            if (value <= 0) {
                throw new TypeError('Age must be a positive number')
            }
        }
        return true
    }
}
const person = {
    age: 27
}
const proxy = new Proxy(person, validator)
proxy.age = 'foo'
// <- TypeError: Age must be a number
proxy.age = NaN
// <- TypeError: Age must be a number
proxy.age = 0
// <- TypeError: Age must be a positive number
proxy.age = 28
console.log(person.age)
// <- 28

// 添加监控
window.addEventListener(
    'error',
    e => {
        console.log(e.message) // Uncaught TypeError: Age must be a number
    },
    true
)
```

**场景 4**

什么实例一个对象，每个对象都有一个自己的 id 而且只读。

```js
class Component {
    constructor() {
        this.proxy = new Proxy({
            id: Math.random().toString(36).slice(-8)
        })
    }
    get id() {
        return this.proxy.id
    }
}
```

#### 12.3.常用拦截操作

**get**

拦截对象属性的读取，比如proxy.foo和proxy['foo']。

```js
let arr = [7, 8, 9]
arr = new Proxy(arr, {
    get(target, prop) {
        // console.log(target, prop)
        return prop in target ? target[prop] : 'error'
    }
})
console.log(arr[1])
console.log(arr[10])
let dict = {
    'hello': '你好',
    'world': '世界'
}
dict = new Proxy(dict, {
    get(target, prop) {
        return prop in target ? target[prop] : prop
    }
})
console.log(dict['world'])
console.log(dict['imooc'])
```

**set**

拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

```js
let arr = []
arr = new Proxy(arr, {
    set(target, prop, val) {
        if (typeof val === 'number') {
            target[prop] = val
            return true
        } else {
            return false
        }
    }
})
arr.push(5)
arr.push(6)
console.log(arr[0], arr[1], arr.length)
```

**has**

拦截propKey in proxy的操作，返回一个布尔值。

```js
let range = {
    start: 1,
    end: 5
}

range = new Proxy(range, {
    has(target, prop) {
        return prop >= target.start && prop <= target.end
    }
})
console.log(2 in range)
console.log(9 in range)
```

**ownKeys**

拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。

```js
let obj = {
    name: 'imooc',
    [Symbol('es')]: 'es6'
}
console.log(Object.getOwnPropertyNames(obj))
console.log(Object.getOwnPropertySymbols(obj))
console.log(Object.keys(obj))
for (let key in obj) {
    console.log(key)
}
let userinfo = {
    username: 'xiecheng',
    age: 34,
    _password: '***'
}
userinfo = new Proxy(userinfo, {
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'))
    }
})

// for (let key in userinfo) {
//     console.log(key)
// }
console.log(Object.keys(userinfo))
```

**deleteProperty**

拦截delete proxy[propKey]的操作，返回一个布尔值。

```js
let user = {
    name: 'xiecheng',
    age: 34,
    _password: '***'
}
user = new Proxy(user, {
    get(target, prop) {
        if (prop.startsWith('_')) {
            throw new Error('不可访问')
        } else {
            return target[prop]
        }
    },
    set(target, prop, val) {
        if (prop.startsWith('_')) {
            throw new Error('不可访问')
        } else {
            target[prop] = val
            return true
        }
    },
    deleteProperty(target, prop) { // 拦截删除
        if (prop.startsWith('_')) {
            throw new Error('不可删除')
        } else {
            delete target[prop]
            return true
        }
    },
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'))
    }
})
console.log(user.age)
console.log(user._password)
user.age = 18
console.log(user.age)
try {
    user._password = 'xxx'
} catch (e) {
    console.log(e.message)
}

try {
    // delete user.age
    delete user._password
} catch (e) {
    console.log(e.message)
}
console.log(user.age)

for (let key in user) {
    console.log(key)
}
```

**apply**

拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。

```js
let sum = (...args) => {
    let num = 0
    args.forEach(item => {
        num += item
    })
    return num
}

sum = new Proxy(sum, {
    apply(target, ctx, args) {
        return target(...args) * 2
    }
})
console.log(sum(1, 2))
console.log(sum.call(null, 1, 2, 3))
console.log(sum.apply(null, [1, 2, 3]))
```

**construct**

拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

```js
let User = class {
    constructor(name) {
        this.name = name
    }
}
User = new Proxy(User, {
    construct(target, args, newTarget) {
        console.log('construct')
        return new target(...args)
    }
})
console.log(new User('imooc'))
```

### 13.Reflect

Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。

#### 12.1.设计目的

- 将Object属于语言内部的方法放到Reflect上

```js
let obj = {}
let newVal = ''
Reflect.defineProperty(obj, 'name', {
    get() {
        return newVal
    },
    set(val) {
        console.log('set')
        // this.name = val
        newVal = val
    }
})
obj.name = 'es'
console.log(obj.name)
```

- 修改某些Object方法的返回结果，让其变得更合理

```js
// 老写法
try {
    Object.defineProperty(target, property, attributes)
    // success
} catch (e) {
    // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
    // success
} else {
    // failure
}
```

- 让Object操作变成函数行为

```js
// 老写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
```

- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。

```js
Proxy(target, {
    set: function(target, name, value, receiver) {
        var success = Reflect.set(target, name, value, receiver)
        if (success) {
            console.log('property ' + name + ' on ' + target + ' set to ' + value)
        }
        return success
    }
})
```

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。

TIP

与大多数全局对象不同，Reflect没有构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）

#### 12.2.常用方法

**Reflect.apply()**

**语法**

> Reflect.apply(target, thisArgument, argumentsList)

**解释**

|     参数      |                             含义                             | 必选 |
| :-----------: | :----------------------------------------------------------: | :--: |
|    target     |                           目标函数                           |  Y   |
| thisArgument  |                target函数调用时绑定的this对象                |  N   |
| argumentsList | target函数调用时传入的实参列表，该参数应该是一个类数组的对象 |  N   |

**示例**

```js
Reflect.apply(Math.floor, undefined, [1.75])
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111])
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index
// 4

Reflect.apply(''.charAt, 'ponies', [3])
// "i"
```

**ES5 对比**

该方法与ES5中Function.prototype.apply()方法类似：调用一个方法并且显式地指定this变量和参数列表(arguments) ，参数列表可以是数组，或类似数组的对象。

```js
Function.prototype.apply.call(Math.floor, undefined, [1.75])
```

**Reflect.construct()**

Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args).

**语法**

> Reflect.construct(target, argumentsList[, newTarget])

**解释**

|     参数      |                             含义                             | 必选 |
| :-----------: | :----------------------------------------------------------: | :--: |
|    target     |                       被运行的目标函数                       |  Y   |
| argumentsList |                 调用构造函数的数组或者伪数组                 |  Y   |
|   newTarget   | 该参数为构造函数， 参考 new.target 操作符，如果没有newTarget参数， 默认和target一样 |  N   |

> [! WARNING] 如果target或者newTarget不是构造函数，抛出TypeError

Reflect.construct允许你使用可变的参数来调用构造函数

```js
var obj = new Foo(...args)
var obj = Reflect.construct(Foo, args)
```

**示例**

```js
var d = Reflect.construct(Date, [1776, 6, 4])
d instanceof Date // true
d.getFullYear() // 1776
```

如果使用 newTarget 参数，则表示继承了 newTarget 这个超类：

```js
function someConstructor() {}
var result = Reflect.construct(Array, [], someConstructor)

Reflect.getPrototypeOf(result) // 输出：someConstructor.prototype
Array.isArray(result) // true
```

**Reflect.defineProperty()**

静态方法 Reflect.defineProperty() 基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。

**语法**

> Reflect.defineProperty(target, propertyKey, attributes)

**解释**

|    参数     |           含义           | 必选 |
| :---------: | :----------------------: | :--: |
|   target    |         目标对象         |  Y   |
| propertyKey | 要定义或修改的属性的名称 |  Y   |
| attributes  | 要定义或修改的属性的描述 |  Y   |

**示例**

```js
const student = {}
Reflect.defineProperty(student, 'name', {
    value: 'Mike'
}) // true
student.name // "Mike"
```

**Reflect.deleteProperty()**

Reflect.deleteProperty 允许你删除一个对象上的属性。返回一个 Boolean 值表示该属性是否被成功删除。它几乎与非严格的 delete operator 相同。

**语法**

> Reflect.deleteProperty(target, propertyKey)

**解释**

|    参数     |         含义         | 必选 |
| :---------: | :------------------: | :--: |
|   target    |  删除属性的目标对象  |  Y   |
| propertyKey | 将被删除的属性的名称 |  Y   |

**示例**

```js
var obj = {
    x: 1,
    y: 2
}
Reflect.deleteProperty(obj, "x") // true
obj // { y: 2 }

var arr = [1, 2, 3, 4, 5]
Reflect.deleteProperty(arr, "3") // true
arr // [1, 2, 3, , 5]

// 如果属性不存在，返回 true
Reflect.deleteProperty({}, "foo") // true

// 如果属性不可配置，返回 false
Reflect.deleteProperty(Object.freeze({
    foo: 1
}), "foo") // false
```

**Reflect.get()**

Reflect.get() 方法的工作方式，就像从 object (target[propertyKey]) 中获取属性，但它是作为一个函数执行的。

**语法**

> Reflect.get(target, propertyKey[, receiver])

**解释**

|    参数     |                 含义                  | 必选 |
| :---------: | :-----------------------------------: | :--: |
|   target    |          需要取值的目标对象           |  Y   |
| propertyKey |          需要获取的值的键值           |  Y   |
|  receiver   | 如果遇到 getter，此值将提供给目标调用 |  N   |

**示例**

```js
// Object
var obj = {
    x: 1,
    y: 2
}
Reflect.get(obj, 'x') // 1

// Array
Reflect.get(['zero', 'one'], 1) // "one"

// Proxy with a get handler
var x = {
    p: 1
}
var obj = new Proxy(x, {
    get(t, k, r) {
        return k + 'bar'
    }
})
Reflect.get(obj, 'foo') // "foobar"
```

**Reflect.getOwnPropertyDescriptor()**

静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回 undefined。

**语法**

> Reflect.getOwnPropertyDescriptor(target, propertyKey)

**解释**

|    参数     |               含义               | 必选 |
| :---------: | :------------------------------: | :--: |
|   target    |      需要寻找属性的目标对象      |  Y   |
| propertyKey | 获取自己的属性描述符的属性的名称 |  N   |

**示例**

```js
Reflect.getOwnPropertyDescriptor({
    x: 'hello'
}, 'x')
// {value: "hello", writable: true, enumerable: true, configurable: true}

Reflect.getOwnPropertyDescriptor({
    x: 'hello'
}, 'y')
// undefined

Reflect.getOwnPropertyDescriptor([], 'length')
// {value: 0, writable: true, enumerable: false, configurable: false}
```

**对比**

如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误。而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理。

```js
Reflect.getOwnPropertyDescriptor("foo", 0)
// TypeError: "foo" is not non-null object

Object.getOwnPropertyDescriptor("foo", 0)
// { value: "f", writable: false, enumerable: true, configurable: false }
```

**Reflect.getPrototypeOf()**

静态方法 Reflect.getPrototypeOf() 与 Object.getPrototypeOf() 方法是一样的。都是返回指定对象的原型（即，内部的 [[Prototype]] 属性的值）。

**语法**

> Reflect.getPrototypeOf(target)

**解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

**Reflect.has()**

Reflect.has 用于检查一个对象是否拥有某个属性， 相当于in 操作符

**语法**

> Reflect.has(target, propertyKey)

**解释**

|    参数     |                  含义                  | 必选 |
| :---------: | :------------------------------------: | :--: |
|   target    |           获取原型的目标对象           |  Y   |
| propertyKey | 属性名，需要检查目标对象是否存在此属性 |  Y   |

**Reflect.isExtensible()**

Reflect.isExtensible 判断一个对象是否可扩展 （即是否能够添加新的属性），它与 Object.isExtensible() 方法一样。

**语法**

> Reflect.isExtensible(target)

*解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

**Reflect.ownKeys()**

Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))

**语法**

> Reflect.ownKeys(target)

*解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

**示例**

```js
Reflect.ownKeys({
    z: 3,
    y: 2,
    x: 1
}) // [ "z", "y", "x" ]
Reflect.ownKeys([]) // ["length"]

var sym = Symbol.for("comet")
var sym2 = Symbol.for("meteor")
var obj = {
    [sym]: 0,
    "str": 0,
    "773": 0,
    "0": 0,
    [sym2]: 0,
    "-1": 0,
    "8": 0,
    "second str": 0
}
Reflect.ownKeys(obj)
// [ "0", "8", "773", "str", "-1", "second str", Symbol(comet), Symbol(meteor) ]
// Indexes in numeric order,
// strings in insertion order,
// symbols in insertion order
```

**Reflect.preventExtensions()**

Reflect.preventExtensions 方法阻止新属性添加到对象 例如：防止将来对对象的扩展被添加到对象中)。该方法与 Object.preventExtensions() 方法一致

**语法**

> Reflect.preventExtensions(target)

*解释**

|  参数  |        含义        | 必选 |
| :----: | :----------------: | :--: |
| target | 获取原型的目标对象 |  Y   |

**示例**

```js
// Objects are extensible by default.
var empty = {}
Reflect.isExtensible(empty) // === true

// ...but that can be changed.
Reflect.preventExtensions(empty)
Reflect.isExtensible(empty) // === false
Reflect.preventExtensions(1)
// TypeError: 1 is not an object

Object.preventExtensions(1)
// 1
```

**Reflect.set()**

Reflect.set 方法允许你在对象上设置属性。它的作用是给属性赋值并且就像 property accessor 语法一样，但是它是以函数的方式。

**语法**

> Reflect.set(target, propertyKey, value[, receiver])

*解释**

|    参数     |                  含义                  | 必选 |
| :---------: | :------------------------------------: | :--: |
|   target    |           获取原型的目标对象           |  Y   |
| propertyKey |            设置的属性的名称            |  Y   |
|    value    |                设置的值                |  Y   |
|  receiver   | 如果遇到 setter，this 将提供给目标调用 |  N   |

**示例**

```js
// Object
var obj = {}
Reflect.set(obj, "prop", "value") // true
obj.prop // "value"

// Array
var arr = ["duck", "duck", "duck"]
Reflect.set(arr, 2, "goose") // true
arr[2] // "goose"

// It can truncate an array.
Reflect.set(arr, "length", 1) // true
arr // ["duck"]

// With just one argument, propertyKey and value are "undefined".
var obj = {}
Reflect.set(obj) // true
Reflect.getOwnPropertyDescriptor(obj, "undefined")
// { value: undefined, writable: true, enumerable: true, configurable: true }
```

**Reflect.setPrototypeOf()**

Reflect.setPrototypeOf 方法改变指定对象的原型 （即，内部的 [[Prototype]] 属性值）

**语法**

> Reflect.setPrototypeOf(target, prototype)

*解释**

|   参数    |               含义               | 必选 |
| :-------: | :------------------------------: | :--: |
|  target   |        获取原型的目标对象        |  Y   |
| prototype | 对象的新原型 （一个对象或 null） |  Y   |

**示例**

```js
Reflect.setPrototypeOf({}, Object.prototype) // true

// It can change an object's [[Prototype]] to null.
Reflect.setPrototypeOf({}, null) // true

// Returns false if target is not extensible.
Reflect.setPrototypeOf(Object.freeze({}), null) // false

// Returns false if it cause a prototype chain cycle.
var target = {}
var proto = Object.create(target)
Reflect.setPrototypeOf(target, proto) // false
```

注意

对于以上所有 API 第一个参数是 Object 的，如果给定的不是 Object 则抛出一个 TypeError 异常

### 14.Promise对象

####  12.1.异步操作前置知识

**JS是单线程的**

就是同一个时间只能处理一个任务。就类似生活中的去超市排队结账，正常情况下，一位收银员只能为一位顾客结账，其他顾客需要在后面排队等候。

为什么 JS 是单线程的？作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM 。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

单线程就意味着，所有任务都需要排队，前一个任务结束，才能执行后一个任务。如果前一个任务耗时很长，那么后一个任务就不得不一直等待，于是乎，JS 设计者们把所有任分成两类，同步和异步。

- 同步：同一时间只能执行一个任务，只有前一个任务执行完毕，才能执行后一个任务
- 异步：同一时间可以执行多个任务，当同步任务执行到某个 WebAPI 时，就会触发异步操作，此时浏览器会单独开线程去处理这些异步任务。

```js
 // 同步
 const a = 2
 const b = 3
 console.log(a + b)

 // 异步
 setTimeout(() => {
     console.log(a + b)
 }, 1000)
```

请思考下面的输出结果是什么？

```js
console.log(1)
setTimeout(() => { // 异步任务，放入任务队列中
    console.log(2)
}, 0)
console.log(3)

// 1、3、2
```

下图说明了同步任务和异步任务的执行过程： ![img](http://es.xiecheng.live/assets/img/task.9fef93a6.png)

**Ajax原理**

Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术。Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

```js
// 创建 XMLHttpRequest 对象
const url = 'http://jsonplaceholder.typicode.com/users'
let xmlhttp
if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
    xmlhttp = new XMLHttpRequest()
} else { // code for IE6, IE5
    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")
}

// 发送请求
xmlhttp.open("GET", url, true)
xmlhttp.send()

// 服务端响应
xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
        //    console.log(xmlhttp.responseText)
        let obj = JSON.parse(xmlhttp.responseText)
        console.log(obj)
    }
}
```

**Callback Hell**

JavaScipt 中的许多操作都是异步的，我们把上面的Ajax封装成一个函数：

```js
function ajax(url, callback) {
    let xmlhttp
    if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp = new XMLHttpRequest()
    } else { // code for IE6, IE5
        xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")
    }
    // 发送请求
    xmlhttp.open("GET", url, true)
    xmlhttp.send()
    // 服务端响应
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            //    console.log(xmlhttp.responseText)
            let obj = JSON.parse(xmlhttp.responseText)
            callback(obj)
        }
    }
}
```

我们在static文件夹下放入三个json文件：

a.json:

```json
{
    "a": "我是A"
}
```

b.json:

```json
{
    "b": "我是B"
}
```

c.json:

```json
{
    "c": "我是C"
}
```

我们可以像这样使用：

```js
// 加载并执行脚本
ajax('/static/a.json')
```

函数是异步调用的，因为操作不是立即完成的，而是之后才会完成。

```js
ajax('/static/a.json')
// 下面的代码不会等到ajax执行完才执行
// ...
```

这个过程大家并不陌生，可是如果在回调之后再回调呢？

```js
ajax('static/a.json', res => {
    console.log(res)
    ajax('static/b.json', res => {
        console.log(res)
        ajax('static/c.json', res => {
            console.log(res)
        })
    })
})
```

如果嵌套变多，代码层次就会变深，维护难度也随之增加。

这就被称为 “回调地狱” 或者“回调深渊”。

#### 12.2.邂逅Promise

**理解promise**

* 代表了未来某个将要发生的事件(通常是一个异步操作)

**promise的作用**

* 解决了回调地狱的问题（层层嵌套的回调函数）,使代码更易于维护

**promise对象的3个状态**

* pending: 初始化状态

* fullfilled: 成功状态

* rejected: 失败状态

**基本语法**

Promise 就是为了解决“回调地狱”问题的，它可以将异步操作的处理变得很优雅。回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的。

创建Promise实例。

```js
const promise = new Promise(function(resolve, reject) {
    // ... some code

    if ( /* 异步操作成功 */ ) {
        resolve(value)
    } else {
        reject(error)
    }
})
```

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

- 处理结果正常的话，调用resolve(处理结果值)，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- 处理结果错误的话，调用reject(Error对象)，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。

```js
promise.then(function(value) {
    // success
}, function(error) {
    // failure
})
```

TIP

实际上 Promise 用起来还是比较简单的，是不是可以动手试一试去封装自己业务中应用到的异步操作了（之前用回调写的）？

在这里必须说明下 Promise 内部是有状态的(pending、fulfilled、rejected)，Promise 对象根据状态来确定执行哪个方法。Promise 在实例化的时候状态是默认 pending 的，当异步操作是完成的，状态会被修改为 fulfilled，如果异步操作遇到异常，状态会被修改为 rejected，可以通过下图来看下状态的走向：

![img](http://es.xiecheng.live/assets/img/promise.04ed9cc2.png)

注意

状态转化是单向的，不可逆转，已经确定的状态（fulfilled/rejected）无法转回初始状态（pending），而且只能是从 pending 到 fulfilled 或者 rejected

##### 12.2.1.Promise.prototype.then()

**基本语法**

> promise.then(onFulfilled, onRejected)

**示例**

```js
var promise = new Promise(function(resolve, reject) {
    resolve('传递给then的值')
})
promise.then(function(value) {
    console.log(value)
}, function(error) {
    console.error(error)
})
```

这段代码创建一个 Promise 对象，定义了处理 onFulfilled 和 onRejected 的函数（handler），然后返回这个 Promise 对象。

这个 Promise 对象会在变为 resolve 或者 reject 的时候分别调用相应注册的回调函数。

- 当 handler 返回一个正常值的时候，这个值会传递给 Promise 对象的 onFulfilled 方法。
- 定义的 handler 中产生异常的时候，这个值则会传递给 Promise 对象的 onRejected 方法。

##### 12.2.2.Promise.prototype.catch()

捕获异常是程序质量保障最基本的要求，可以使用 Promise 对象的 catch 方法来捕获异步操作过程中出现的任何异常。

**基本语法**

> p.catch(onRejected)

> p.catch(function(reason) {

// rejection })

**示例**

```js
function test() {
    return new Promise((resolve, reject) => {
        reject(new Error('es'))
    })
}

test().catch((e) => {
    console.log(e.message) // es
})
```

这个代码展示了如何使用 catch 捕获 Promise 对象中的异常，有的同学会问 catch 捕获的是 Promise 内部的 Error 还是 Reject？上面的示例既用了 reject 也用了 Error，到底是哪个触发的这个捕获呢？

```js
function test() {
    return new Promise((resolve, reject) => {
        throw new Error('wrong')
    })
}

test().catch((e) => {
    console.log(e.message) // wrong
})
```

这个代码对比着上个代码就能明显感受出来的，throw Error 和 reject 都触发了 catch 的捕获，而第一个用法中虽然也有 Error 但是它不是 throw，只是 reject 的参数是 Error 对象，换句话说 new Error 不会触发 catch，而是 reject。

注意

不建议在 Promise 内部使用 throw 来触发异常，而是使用 `reject(new Error())` 的方式来做，因为 throw 的方式并没有改变 Pronise 的状态

##### 12.2.3.Promise.resolve()

一般情况下我们都会使用 ```new Promise()` ``来创建 Promise 对象，但是除此之外我们也可以使用其他方法。

在这里，我们将会学习如何使用 Promise.resolve 和 Promise.reject 这两个方法。

静态方法 Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。

比如 Promise.resolve(42) 可以认为是以下代码的语法糖。

```js
new Promise(function(resolve) {
    resolve(42)
})
```

在这段代码中的 resolve(42) 会让这个 Promise 对象立即进入确定（即resolved）状态，并将 42 传递给后面 then 里所指定的 onFulfilled 函数。

方法 Promise.resolve(value) 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。

```js
Promise.resolve(42).then(function(value) {
    console.log(value)
})
```

Promise.resolve 作为 new Promise() 的快捷方式，在进行 Promise 对象的初始化或者编写测试代码的时候都非常方便。

##### 12.2.4.Promise.reject()

Promise.reject(error) 是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。

比如 Promise.reject(new Error("出错了")) 就是下面代码的语法糖形式。

```js
new Promise(function(resolve, reject) {
    reject(new Error('出错了'))
})
```

这段代码的功能是调用该Promise 对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。

```js
Promise.reject(new Error('BOOM!'))
```

##### 12.2.5Promise.all()

**基本语法**

> Promise.all(promiseArray)

**示例**

```js
var p1 = Promise.resolve(1)
var p2 = Promise.resolve(2)
var p3 = Promise.resolve(3)
Promise.all([p1, p2, p3]).then(function(results) {
    console.log(results) // [1, 2, 3]
})
```

Promise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递promise数组中所有的 Promise 对象都变为resolve的时候，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。

如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的 Promise 对象。

由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以Promise.all 可以处理不同类型的 Promise 对象。

**应用场景**

比如当我们需要批量上传图片的时候，当全部上传完图片后需要弹出提示时，可以使用。

##### 12.2.6.Promise.race()

**基本语法**

> Promise.race(promiseArray)

**示例**

```js
var p1 = Promise.resolve(1)
var p2 = Promise.resolve(2)
var p3 = Promise.resolve(3)
Promise.race([p1, p2, p3]).then(function(value) {
    console.log(value) // 1
})
```

<<<<<<< HEAD
Promise.race 生成并返回一个新的 Promise 对象。

参数 promise 数组中的任何一个 Promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 Promise 对象的值进行 resolve 或者 reject。

**练习**

如何把前面Callback Hell的代码改写成promise的写法呢？

```js
function getPromise(url) {
    return new Promise((resolve, reject) => {
        ajax(url, res => {
            resolve(res)
        }, err => {
            reject(err)
        })
    })
}

getPromise('static/a.json')
    .then(res => {
        console.log(res)
        return getPromise('static/b.json')
    }).then(res => {
        console.log(res)
        return getPromise('static/c.json')
    }).then(res => {
        console.log(res)
    }).catch(err => {
        console.log(err)
    })
```

### 15.iterator接口机制
1.理解：

* iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制

2.作用：

* 为各种数据结构，提供一个统一的、简便的访问接口；

* 使得数据结构的成员能够按某种次序排列

* ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。

3.工作原理：

* 创建一个指针对象，指向数据结构的起始位置。

* 第一次调用next方法，指针自动指向数据结构的第一个成员

* 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员

* 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}

* value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。

* 当遍历结束的时候返回的value值是undefined，done值为false

```
function myIteraor(arr) {
	let index = 0 //记录指针的位置
	return {
		next() {
			return {
				value[index++],
				done: index < arr.length - 1  ? false : true
			}
		}
	}
}
let arr = [1, 2, 3, 5, 2]

console.log(myIteraor.next(arr))
console.log(myIteraor.next(arr))
console.log(myIteraor.next(arr))
```

4.原生具备iterator接口的数据(可用for of遍历)

* Array、arguments、set容器、map容器、String...

``` 
let arr = [1, 2, 'abc']
for(let i of arr) {
	console.log(i) // 1, 2, 'abc'
}
let str = 'abc'
for(let j of str) {
	console.log(j) // a, b, c
}
function fun() {
	for(let i of arguments) {
		console.log(i) // 1, "fun", 44
	}
}
fun(1, "fun", 44)
let obj = {
	name: "jack",
	age: 12
}
for(let z of obj) {
	console.log(z) // obj is not iterable (obj 不是可迭代的)
}
```

### 16.Generator函数

#### 13.1.认识Generator

什么是 JavaScript Generators 呢？通俗的讲 Generators 是可以用来控制迭代器的函数。它们可以暂停，然后在任何时候恢复。如果这句话不好理解，可以看下接下来的示例。

**1. 常规循环**

```js
for (let i = 0; i < 5; i += 1) {
    console.log(i)
}
// this will return immediately 0 -> 1 -> 2 -> 3 -> 4
```

**2. 利用 Generator**

```js
function* generatorForLoop() {
    for (let i = 0; i < 5; i += 1) {
        yield console.log(i)
    }
}

const genForLoop = generatorForLoop()

console.log(genForLoop.next()) // first console.log - 0
console.log(genForLoop.next()) // 1
console.log(genForLoop.next()) // 2
console.log(genForLoop.next()) // 3
console.log(genForLoop.next()) // 4
```

对比下代码，常规的循环只能一次遍历完所有值，Generator 可以通过调用 next 方法拿到依次遍历的值，让遍历的执行变得“可控”。

>Generator函数的特点：
>
>* ES6提供的解决异步编程的方案之一
>* Generator函数是一个状态机，内部封装了不同状态的数据，
>
>* 用来生成遍历器对象

#### 13.2.基本语法

**定义**

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

let g = gen()
// "Generator { }"
```

这个是 Generator 的定义方法，有几个点值得注意：

1. 比普通函数多一个 *

2. 函数内部用 yield 来控制程序的执行的“暂停”

3. generator函数返回的是指针对象，而不会执行函数内部逻辑

4. generator函数的返回值通过调用 next 来“恢复”程序执行，直到再次遇到yield或程序执行完毕

   

注意

Generator 函数的定义不能使用箭头函数，否则会触发 SyntaxError 错误

```js
let generator = * () => {} // SyntaxError
let generator = () * => {} // SyntaxError
let generator = ( * ) => {} // SyntaxError
```

这些做法都是错误的❌。

**yield 表达式**

> yield 关键字用来暂停和恢复一个生成器函数

关于 yield 表达式，要熟记几个知识点：

1. yield 表达式的返回值是 undefined，但是遍历器对象的 next 方法可以修改这个默认值。

```js
  function* gen() {
      let val
      val = yield 1
      console.log( `1:${val}` ) // 1:undefined
      val = yield 2
      console.log( `2:${val}` ) // 2:undefined
      val = yield 3
      console.log( `3:${val}` ) // 3:undefined
  }

  var g = gen()

  console.log(g.next()) // {value: 1, done: false}
  console.log(g.next()) // {value: 2, done: false}
  console.log(g.next()) // {value: 3, done: false}
  console.log(g.next()) // {value: undefined, done: true}
```

从这个代码可以看出来，yield 表达式的返回值是 undefined。

1. yeild * 是委托给另一个遍历器对象或者可遍历对象

```js
  function* gen() {
      let val
      val = yield 1
      console.log( `1:${val}` ) // 1:undefined
      val = yield 2
      console.log( `2:${val}` ) // 2:undefined
      val = yield [3, 4, 5]
      console.log( `3:${val}` ) // 3:undefined
  }
```

1. Generator 对象的 next 方法，遇到 yield 就暂停，并返回一个对象，这个对象包括两个属性：value 和 done。

参考步骤1 的代码可以明确看出来，执行第一句 ```g.next` ``gen 代码执行到 yield 1，程序暂停，此时返回了一个对象：{value: 1, done: false}

**方法**

Generator 对象有几个方法，next、return、throw。

**- next([value])**

前面我们讲了，Generator 对象通过 next 方法来获取每一次遍历的结果，这个方法返回一个对象，这个对象包含两个属性：value 和 done。value 是指当前程序的运行结果，done 表示遍历是否结束。

其实 next 是可以接受参数的，这个参数可以让你在 Generator 外部给内部传递数据，而这个参数就是作为 yield 的返回值。

```js
  function* gen() {
      var val = 100
      while (true) {
          console.log( `before ${val}` )
          val = yield val
          console.log( `return ${val}` )
      }
  }

  var g = gen()
  console.log(g.next(20).value)
  // before 100
  // 100
  console.log(g.next(30).value)
  // return 30
  // before 30
  // 30
  console.log(g.next(40).value)
  // return 40
  // before 40
  // 40
```

如果对上面的话和代码不理解，可以把 ```console.log(g.next(30).value)` ``和 ```console.log(g.next(40).value)` ``注释掉。你会发现 只输出了 before 100 和 100，这是为什么呢？下面我们来还原下这段代码的执行过程：

1. g.next(20) 这句代码会执行 gen 内部的代码，遇到第一个 yield 暂停。所以 ```console.log(` before ${val} `)` ``执行输出了 ```before 100` ``，此时的 val 是 100，所以执行到 yield val 返回了 100，注意 ```yield val` ``并没有赋值给 val。
2. g.next(30) 这句代码会继续执行 gen 内部的代码，也就是 ```val = yield val` ``这句，因为 next 传入了 30，所以 yield val 这个返回值就是 30，因此 val 被赋值 30，执行到 ```console.log(` return ${val} `)` ``输出了 30，此时没有遇到 yield 代码继续执行，也就是 while 的判断，继续执行 ```console.log(` before ${val} `)` ``输出了 ```before 30` ``，再执行遇到了 ```yield val` ``程序暂停。
3. g.next(40) 重复步骤 2。

**- return()**

return 方法可以让 Generator 遍历终止，有点类似 for 循环的 break。

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

var g = gen()

console.log(g.next()) // {value: 1, done: false}
console.log(g.return()) // {value: undefined, done: true}
console.log(g.next()) // {value: undefined, done: true}
```

从 done 可以看出代码执行已经结束。

当然 return 也可以传入参数，作为返回的 value 值。

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

var g = gen()

console.log(g.next()) // {value: 1, done: false}
console.log(g.return(100)) // {value: 100, done: true}
console.log(g.next()) // {value: undefined, done: true}
```

**- throw()**

可以通过 throw 方法在 Generator 外部控制内部执行的“终断”。

```js
function* gen() {
    while (true) {
        try {
            yield 42
        } catch (e) {
            console.log(e.message)
        }
    }
}

let g = gen()
console.log(g.next()) // { value: 42, done: false }
console.log(g.next()) // { value: 42, done: false }
console.log(g.next()) // { value: 42, done: false }
// 中断操作
g.throw(new Error('break'))

console.log(g.next()) // {value: undefined, done: true}
```

TIP

如果想退出遍历 catch 之后可以配合 ```return false` ``使用，能起到 “break” 的作用

#### 13.3.应用场景

**场景1**

还是前面的异步操作，按顺序读取a.json、b.json、c.json，如果使用Generator该如何实现呢？

```js
function request(url) {
    ajax(url, res => {
        getData.next(res)
    })
}

function* gen() {
    let res1 = yield request('static/a.json')
    console.log(res1)
    let res2 = yield request('static/b.json')
    console.log(res2)
    let res3 = yield request('static/c.json')
    console.log(res3)
}
let getData = gen()
getData.next()
```

**场景2**

我们经常玩一些小游戏，比如数数字，敲7，到7和7的倍数，无限循环转圈去数数

```js
function* count(x = 1) {
    while (true) {
        if (x % 7 === 0) {
            yield x
        }
        x++
    }
}
// es5中就是个死循环 因为es5的循环需要有个终止值，但我们这个需求没有终止，一直在数数
let n = count()
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
console.log(n.next().value)
```

通过 Generator 我们就能轻松实现，只要调用 n.next 我们就知道下一个数是什么了，而使用普通函数却没法做到

* 缺点：本质上还是没有脱离回调函数

### 17.class类使用详解

#### 15.1.ES5实现继承

```
function Parent(name, age) {
	this.name = name
	this.age = age // 实例属性
	Parent.name = 32 // 静态属性
	Parent.getName = function() {
		return this.name
	}
}
Parent.prototype.getName = function() { // 实例方法
	return this.name 
}

function Child(name, age) {
	Parent.call(this, name, age)
}

// 使实例可访问父类的原型方法
Child.prototype = new Parent() 
Child.contructor = Parent

const person = new Child('chh', 12)
console.log(person) { name: 'chh', age: 12 }
console.log(Parent.getName()) // 32
```



#### 15.2.ES6实现继承

* 通过class实现类的继承
  * 通过constructor定义构造方法
  * 通过new来创建类的实例
  * 通过extends来实现类的继承
  * 通过super调用父类的构造方法

```
class Person {
	constructor(name, age) {
		this.name = name
		this.age = age
		this._sex = 0
	}
	// 必须用对象简写,保存在实例的原型中
	showName() {
		console.log(this.name)
	}
	get sex() {
		if(this._sex === 0) return 'male'
		if(this._sex === 1) return 'female'
		return 'error'
	}
	set sex(val) {
		if(val !== 0 && val !== 1) return
		this._sex = val
	}
}
let person = new Person("jack", 12)
console.log(person) // {name: "jack", age: 12}
person.showName() // "jack"

// 子类继承父类
class childPerson extends Person{
	constructor(name, age, salary) {
		super(name, age)
		this.salary = salary
	}
	// 类似于java方法的重写,不重写则用父类的原型的方法
	showName() {
		console.log("子类的方法")
		console.log(this.name)
	}
}
let person = new ChildPerson("jack", 13, 100000)
console.log(person)  // {name: "jack", age: 13, salary: 100000}
person.showName // jcak
```

### 18.Set，Map容器

1.Set容器：无序不可重复的多个value的集合体

* Set(array)
* add(value)
* delete(value)
* has(value)
* clear()
* size

```
let setArr = new Set([1, 4, 2, 3, 4, 3, 5])
console.log(setArr) // {1, 4, 2, 3, 5, size: 5}
setArr.add(2) // 不变
setArr.add(7) // {1, 4, 2, 3, 5, 7, size: 6}
setArr.delete(2) // {1, 4, 3, 5, 7, size: 5}
setArr.has(1) // true
setArr.clear() // {size: 0}
```

2.Map容器：无序的key不重复的多个key-value的集合体

* Map(array)
* set(key, value)
* get(key)
* delete(key)
* has(key)
* clear()
* size

```
let setArr = new Map([["name", "jack"],["age", 12]])
console.log(setArr) // {"name" => "jack", "age" => 12, size: 2}
setArr.set("address", "beijin") // {"name" => "jack", "age" => 12, "address" => "beijin", size: 3}
setArr.get("name") // "jack"
setArr.delete("name") // {"age" => 12, "address" => "beijin", size: 2}
setArr.has("address") // true
setArr.clear() // {size: 0}
```

## ES7

### 01.Array.prototype.includes()

在 ES7 之前想判断数组中是否包含一个元素，基本可以这样写：

```js
console.log(array1.find(function(item) {
    return item === 2
}))
```

或者

```js
console.log(array1.filter(function(item) {
    return item === 2
}).length > 0)
```

ES7引入的Array.prototype.includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

#### 1.1.基本用法

```js
const arr = ['es6', 'es7', 'es8']
console.log(arr.includes('es6')) // true
console.log(arr.includes('es9')) // false
```

#### 1.2.接收俩个参数

要搜索的值和搜索的开始索引。第二个参数可选。从该索引处开始查找 searchElement。如果为负值，

```js
const arr = ['es6', 'es7', 'es8']
console.log(arr.includes('es7', 1)) // true
console.log(arr.includes('es7', 2)) // false
console.log(arr.includes('es7', -1)) // false
console.log(arr.includes('es7', -2)) // true
```

#### 1.3.与indexOf()比较

```js
['a', 'b', 'c'].includes('a') //true
['a', 'b', 'c'].indexOf('a') > -1 //true

console.log(arr.indexOf('es7')) // 1
console.log(arr.indexOf('es7') > -1) // true
```

注意

只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些是无法判断的.

```js
const arr = [1, [2, 3], 4]
arr.includes([2, 3]) //false
arr.indexOf([2, 3]) //-1
```

#### 1.4.优缺点比较

两者都是采用===的操作符来作比较的，不同之处在于：对于NaN的处理结果不同。我们知道js中 NaN === NaN 的结果是false, indexOf()也是这样处理的，但是includes()不是这样的。

```js
const demo = [1, NaN, 2, 3]
demo.indexOf(NaN) //-1
demo.includes(NaN) //true
```

总结

如果只想知道某个值是否在数组中存在，而并不关心它的索引位置，建议使用includes()。如果想获取一个值在数组中的位置，那么只能使用indexOf方法。

### 02.幂运算符**

如果不使用任何函数，如何实现一个数的求幂运算？

```js
function pow(x, y) {
    let res = 1
    for (let i = 0; i < y; i++) {
        res *= x
    }
    return res
}

pow(2, 10)
// 1024
```

除了自己封装函数来实现，也可是使用 `Math.pow()` 来完成。

> Math.pow() 函数返回基数（base）的指数（exponent）次幂。

```js
console.log(Math.pow(2, 10)) // 1024
```

在 ES7 可以这样写了：

```js
console.log(2 ** 10) // 1024
```

>注意
>
>幂运算符的两个*号之间不能出现空格，否则语法会报错。

## ES8

### 01.async/await

async 和 await 是一种更加优雅的异步编程解决方案，是Promise 的拓展，如果对 Promise 还不了解的话，请移步 [Promise](http://es.xiecheng.live/es6/promise.html) 章节进行学习。

在我们处理异步的时候，比起回调函数，Promise的then方法会显得较为简洁和清晰，但是在处理多个彼此之间相互依赖的请求的时候，就会显的有些繁琐。这时候，用async/await更加优雅。

我们知道 JavaScript 是单线程的，使用 Promise 之后可以让我们书写异步操作更加简单，而 async 是让我们写起 Promise 像同步操作。看下示例：

#### 1.1.基本语法

前面添加了async的函数在执行后都会自动返回一个Promise对象:

```js
function foo() {
    return 'imooc'
}
console.log(foo()) // 'imooc'
```

相当于

```js
async function foo() {
    return 'imooc' // Promise.resolve('imooc')

    // let res =  Promise.resolve('imooc')
    // console.log(res)
}
console.log(foo()) // Promise
foo()
```

await后面需要跟异步操作，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数。

```js
function timeout() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log(1)
            resolve() // resolve('success')
        }, 1000)
    })
}

// 不加async和await是2、1   加了是1、2
async function foo() {
    await timeout() // let res = await timeout() res是success
    console.log(2)
}
foo()
```

#### 1.2.对于失败的处理

```js
function timeout() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve('success')
            reject('error')
        }, 1000)
    })
}
async function foo() {
    return await timeout()
}
foo().then(res => {
    console.log(res)
}).catch(err => {
    console.log(err)
})
```

在async函数中使用await，那么await这里的代码就会变成同步的了，意思就是说只有等await后面的Promise执行完成得到结果才会继续下去，await就是等待。

#### 1.3.应用

还是前面案例中的异步操作，我们需要发送多个请求，而后面请求的发送总是需要依赖上一个请求返回的数据。对于这个问题，我们既可以用的Promise的链式调用来解决，也可以用async/await来解决，然而后者会更简洁些。

按顺序读取a.json、b.json、c.json，如果使用async/await该如何实现呢？

我们在static文件夹下放入三个json文件：

a.json:

```json
{
    "a": "我是A"
}
```

b.json:

```json
{
    "b": "我是B"
}
```

c.json:

```json
{
    "c": "我是C"
}
// 把ajax封装成模块
import ajax from './ajax'

function request(url) {
    return new Promise(resolve => {
        ajax(url, res => {
            resolve(res)
        })
    })
}
async function getData() {
    let res1 = await request('static/a.json')
    console.log(res1)
    let res2 = await request('static/b.json')
    console.log(res2)
    let res3 = await request('static/c.json')
    console.log(res3)
}
getData()
```

>注意
>
>await 只能在 async 标记的函数内部使用，单独使用会触发 Syntax error。

### 02.对象的扩展

之前的语法如何获取对象的每一个属性值

```js
const obj = {
    name: 'imooc',
    web: 'www.imooc.com',
    course: 'es'
}
console.log(Object.keys(obj))
const res = Object.keys(obj).map(key => obj[key])
console.log(res)
// ["imooc", "www.imooc.com", "es"]
```

ES8中对象扩展补充了两个静态方法，用于遍历对象：Object.values()，Object.entries()

**Object.values()**

> Object.values() 返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同(for...in，但是for...in还会遍历原型上的属性值)。

```js
const obj = {
    name: 'imooc',
    web: 'www.imooc.com',
    course: 'es'
}

console.log(Object.values(obj))
// ["imooc", "www.imooc.com", "es"]
```

TIP

Object.values 是在对象上找到可枚举的属性的值，所以只要这个对象是可枚举的就可以，不只是 {} 这种形式。

**Object.entries()**

> Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致。（区别在于 for-in 循环也枚举原型链中的属性）

```js
let grade = {
    'lilei': 98,
    'hanmei': 87
}

for (let [key, value] of grade) {
    console.log(key, value) // Uncaught TypeError: grade is not iterable
}
```

我们知道 Object 是不可直接遍历的，上述代码足以说明直接遍历触发了错误。如果使用 Object.entries() 则可以完成遍历任务。

```js
let grade = {
    'lilei': 98,
    'hanmei': 87
}

for (let [k, v] of Object.entries(grade)) {
    console.log(k, v)
    // lilei 98
    // hanmei 87
}
```

这段代码确实成功的遍历了出来，但是上边说过 Object.entries 返回的是数组，这里面还用了数组的解构赋值，很多同学不明白是怎么结合的，其实很简单，看下 Object.entries 的返回值就好了：

![img](http://es.xiecheng.live/assets/img/entries.45cb18b2.png)

结合这个图还有解构赋值的原理，就明白上述的代码是怎么工作的了。

**Object.getOwnPropertyDescriptors()**

想理解 Object.getOwnPropertyDescriptors 这个方法之前，首先要弄懂什么是描述符(descriptor)？

```js
const data = {
    Portland: '78/50',
    Dublin: '88/52',
    Lima: '58/40'
}
```

还是上述那个对象，这里有 key 和 value，上边的代码把所有的 key、value 遍历出来，如果我们不想让 Lima 这个属性和值被枚举怎么办？

```js
Object.defineProperty(data, 'Lima', {
    enumerable: false
})

Object.entries(data).map(([city, temp]) => {
    console.log( `City: ${city.padEnd(16)} Weather: ${temp}` )
    // City: Portland         Weather: 78/50
    // City: Dublin           Weather: 88/52
})
```

很成功，Lima 没有被遍历出来，那么 defineProperty 的第三个参数就是描述符(descriptor)。这个描述符包括几个属性：

- value [属性的值]
- writable [属性的值是否可被改变]
- enumerable [属性的值是否可被枚举]
- configurable [描述符本身是否可被修改，属性是否可被删除]

如果想查看更多细节，访问 [Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。

```js
console.log(Object.getOwnPropertyDescriptor(data, 'Lima'))
// {value: "58/40", writable: true, enumerable: false, configurable: true}
```

这个是获取对象指定属性的描述符，如果想获取对象的所有属性的描述符：

```js
console.log(Object.getOwnPropertyDescriptors(data))
```

返回数据： ![img](http://es.xiecheng.live/assets/img/getownproperty.4847f943.png)

## ES9

### 01.for await of

异步迭代器(for-await-of)：循环等待每个Promise对象变为resolved状态才进入下一步。

我们知道 for...of 是同步运行的，有时候一些任务集合是异步的，那这种遍历怎么办呢？

```js
function Gen(time) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(time)
        }, time)
    })
}

async function test() {
    let arr = [Gen(2000), Gen(100), Gen(3000)]
    for (let item of arr) {
        console.log(Date.now(), item.then(console.log))
    }
}

test()
// 1560090138232 Promise {<pending>}
// 1560090138234 Promise {<pending>}
// 1560090138235 Promise {<pending>}
// 100
// 2000
// 3000
```

这里写了几个小任务，分别是 2000ms 、100ms、3000ms后任务结束。在上述遍历的过程中可以看到三个任务是同步启动的，然后输出上也不是按任务的执行顺序输出的，这显然不太符合我们的要求。

聪明的同学一定能想起来 await 的作用，它可以中断程序的执行直到这个 Promise 对象的状态发生改变，我们修改上面的代码：

```js
function Gen(time) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(time)
        }, time)
    })
}

async function test() {
    let arr = [Gen(2000), Gen(100), Gen(3000)]
    for (let item of arr) {
        console.log(Date.now(), await item.then(console.log))
    }
}

test()
// 2000
// 1560091834772 undefined
// 100
// 1560091836774 undefined
// 3000
// 1560091836775 undefined
```

从返回值看确实是按照任务的先后顺序进行的，其中原理也有说明是利用了 await 中断程序的功能。

在 ES9 中也可以用 for...await...of 的语法来操作：

```js
function Gen(time) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(time)
        }, time)
    })
}

async function test() {
    let arr = [Gen(2000), Gen(100), Gen(3000)]
    for await (let item of arr) {
        console.log(Date.now(), item)
    }
}

test()
// 1560092345730 2000
// 1560092345730 100
// 1560092346336 3000
```

从这个结果来看和第二种写法效果差不多，但是工作原理确完全不同，重点观察下输出的时间（Chrome Console）, 第二种写法是代码块中有 await 导致等待 Promise 的状态而不再继续执行；第三种写法是整个代码块都不执行，等待 arr 当前的值（Promise状态）发生变化之后，才执行代码块的内容。

回想我们之前给数据结构自定义遍历器是同步的，如果想定义适合 for...await...of 的异步遍历器该怎么做呢？答案是 Symbol.asyncIterator。

```js
let obj = {
  count: 0, 
  Gen (time) {

    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        resolve({ done: false, value: time })
      }, time)
    })

  }, 
  [Symbol.asyncIterator] () {

    let self = this
    return {
      next () {
        self.count++
        if (self.count < 4) {
          return self.Gen(Math.random() * 1000)
        } else {
          return Promise.resolve({
            done: true,
            value: ''
          })
        }
      }
    }

  }
}

async function test () {
  for await (let item of obj) {

    console.log(Date.now(), item)

  }
}
// 1560093560200 649.3946561938179
// 1560093560828 624.6310222512955
// 1560093561733 901.9497480464518
```

### 02.RegExp Updates

#### 2.1.dotAll 模式

正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。

- U+000A 换行符（\n）
- U+000D 回车符（\r）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（paragraph separator）

```js
console.log(/foo.bar/.test('foo\nbar')) // false
console.log(/foo.bar/s.test('foo\nbar')) // true
```

在 ES5 中我们都是这么解决的：

```js
console.log(/foo[^]bar/.test('foo\nbar')) // true
// or
console.log(/foo[\s\S]bar/.test('foo\nbar')) // true
```

那如何判断当前正则是否使用了 dotAll 模式呢？

```js
const re = /foo.bar/s // Or, `const re = new RegExp('foo.bar', 's')` .
console.log(re.test('foo\nbar')) // true
console.log(re.dotAll) // true
console.log(re.flags) // 's'
```

TIP

记住一句话就可以理解 dotAll 模式：它让 . 名副其实。

#### 2.2.具名组匹配

我们在写正则表达式的时候，可以把一部分用()包裹起来，被包裹起来的这部分称作“分组捕获”。

```js
console.log('2020-05-01'.match(/(\d{4})-(\d{2})-(\d{2})/))
// ["2020-05-01", "2020", "05", "01", index: 0, input: "2020-05-01", groups: undefined]
```

这个正则匹配很简单，按照 match 的语法，没有使用 g 标识符，所以返回值第一个数值是正则表达式的完整匹配，接下来的第二个值到第四个值是分组匹配（2020, 05, 01）。

此外 match 返回值还有几个属性，分别是 index、input、groups。

TIP

1. index [匹配的结果的开始位置]
2. input [搜索的字符串]
3. groups [一个捕获组数组 或 undefined（如果没有定义命名捕获组）]

我们通过数组来获取这些捕获：

```js
let t = '2020-05-01'.match(/(\d{4})-(\d{2})-(\d{2})/)
console.log(t[1]) // 2020
console.log(t[2]) // 05
console.log(t[3]) // 01
```

上文中重点看下 groups 的解释，这里提到了命名捕获组的概念，如果没有定义 groups 就是 undefined。很明显，我们上述的返回值就是 undefined 间接说明没有定义命名捕获分组。那什么是命名捕获分组呢？

```js
console.log('2020-05-01'.match(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/))
// ["2020-05-01", "2020", "05", "01", index: 0, input: "2020-05-01", groups: {…}]
```

这段代码的返回值 groups 已经是 Object 了，具体的值是：

```js
groups: {
    year: "2020",
    month: "05",
    day: "01"
}
```

这个 Object 的 key 就是正则表达式中定义的，也就是把捕获分组进行了命名。想获取这些捕获可以这样做：

```js
let t = '2020-05-01'.match(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/)
// ["2020-05-01", "2020", "05", "01", index: 0, input: "2020-05-01", groups: {…}]
console.log(t.groups.year) // 2020
console.log(t.groups.month) // 05
console.log(t.groups.day) // 01
```

#### 2.3.后行断言

在 ES9 之前 JavaScript 正则只支持先行断言，不支持后行断言。简单复习下先行断言的知识：

```js
let test = 'hello world'
console.log(test.match(/hello(?=\sworld)/))
// ["hello", index: 0, input: "hello world", groups: undefined]
```

这段代码要匹配后面是 world 的 hello，但是反过来就不成：

```js
let test = 'world hello'
console.log(test.match(/hello(?=\sworld)/))
// null
```

比如我们想判断前面是 world 的 hello，这个代码是实现不了的。在 ES9 就支持这个后行断言了：

```js
let test = 'world hello'
console.log(test.match(/(?<=world\s)hello/))
// ["hello", index: 6, input: "world hello", groups: undefined]
```

(?<...)是后行断言的符号，(?...)是先行断言的符号，然后结合 =(等于)、!(不等)、\1(捕获匹配)。

### 03.Object Rest & Spread

前面在讲 function 的 Rest & Spread 方法，忘记的同学可以去复习下。

在 ES9 新增 Object 的 Rest & Spread 方法，直接看下示例：

```js
const input = {
  a: 1,
  b: 2
}

const output = {
  ...input,
  c: 3
}

console.log(output) // {a: 1, b: 2, c: 3}
```

这块代码展示了 spread 语法，可以把 input 对象的数据都拓展到 output 对象，这个功能很实用。

我们再来看下 Object rest 的示例：

```js
const input = {
  a: 1,
  b: 2,
  c: 3
}

let { a, ...rest } = input

console.log(a, rest) // 1 {b: 2, c: 3}
```

当对象 key-value 不确定的时候，把必选的 key 赋值给变量，用一个变量收敛其他可选的 key 数据，这在之前是做不到的。

### 04.Promise.prototype.finally()

指定不管最后状态如何都会执行的回调函数。

Promise.prototype.finally() 方法返回一个Promise，在promise执行结束时，无论结果是fulfilled或者是rejected，在执行then()和catch()后，都会执行finally指定的回调函数。这为指定执行完promise后，无论结果是fulfilled还是rejected都需要执行的代码提供了一种方式，避免同样的语句需要在then()和catch()中各写一次的情况。

**基本语法**

> p.finally(onFinally)

**示例**

```js
new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('success')
        // reject('fail')
    }, 1000)
}).then(res => {
    console.log(res)
}).catch(err => {
    console.log(err)
}).finally(() => {
    console.log('finally')
})
```

#### 4.1.场景1：loading关闭

需要每次发送请求，都会有loading提示，请求发送完毕，就需要关闭loading提示框，不然界面就无法被点击。不管请求成功或是失败，这个loading都需要关闭掉，这时把关闭loading的代码写在finally里再合适不过了。

#### 4.2.场景2：数据库断开链接

```js
let connection
db.open()
    .then(conn => {
        connection = conn
        return connection.select({
            name: 'Jane'
        })
    })
    .then(result => {
        // Process result
        // Use `connection` to make more queries
    })···
    .catch(error => {
        // handle errors
    })
    .finally(() => {
        connection.close()
    })
```

### 05.字符串扩展

放松对标签模板里字符串转义的限制, 遇到不合法的字符串转义返回undefined，并且从raw上可获取原字符串。

ES9开始，模板字符串允许嵌套支持常见转义序列，移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。

// 带标签的模板字符串

```js
const foo = (a, b, c, d) => {
    console.log(a)
    console.log(b)
    console.log(c)
    console.log(d)
}
// foo(1, 2, 3, 4)
const name = 'xiecheng'
const age = 34
foo `这是${name},他的年龄是${age}岁` 
```

ES9 标准移除了对 ECMAScript带标签的模板字符串 中转义序列的语法限制。

```js
function tag(strs) {
    console.log(strs)
    // strs[0] === undefined
    // strs.raw[0] === "\\unicode and \\u{55}"
}

// 在标签函数中使用
tag `\u{61} and \u{62}`  //
tag `\u{61} and \unicode`  // 结果是 undefined

// 之前的版本会报错：Invalid Unicode escape sequence
// 无效的Unicode转义序列

// 报错：
let bad = `bad escape sequence: \unicode` 
```